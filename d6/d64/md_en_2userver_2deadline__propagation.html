<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Deadline propagation</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d64/md_en_2userver_2deadline__propagation.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Deadline propagation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md157"></a> </p>
<h1><a class="anchor" id="autotoc_md158"></a>
Theory</h1>
<p>With deadline propagation, the timeout of each specific request is set not statically, but depending on the time remaining to process the calling service's request.</p>
<p>If the service understands that the parent request is to time out sooner than the other timeouts could fire, then it performs the request with the time remaining to process the parent request. Because of this, after the deadline is reached, no extra time is spent on processing the request, for which no one is waiting anymore.</p>
<p>In general, the deadline propagation feature starts working and significantly helps to save CPU resources only when requests are massively canceled by deadline, that is, when the CPU is overloaded, Congestion Control is turned on, some hosts or services are failing, and so on. That is, it is a mechanism for increasing the stability of multiservice architectures.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
A classic example of deadline propagation</h2>
<p>Let's say, for example, that a request goes through the following services:</p>
<p><code>A -&gt; B -&gt; C</code></p>
<p>Let the static timeout of the service <b>A</b> be 20 seconds, <b>B</b> is 15 seconds, <b>C</b> is 10 seconds.</p>
<p>Without deadline propagation, request processing may look like this:</p>
<ul>
<li><b>A</b> computes something for 12 seconds</li>
<li><b>A</b> sends a request to <b>B</b><ul>
<li><b>B</b> computes something for 8 seconds</li>
</ul>
</li>
<li>The result of the request chain is sure to be discarded by the caller of <b>A</b></li>
<li><b>B</b> continues to compute something for another 4 seconds (pointlessly)</li>
<li><b>B</b> sends a request to <b>C</b> (pointlessly)</li>
<li>...</li>
<li>Results from the request chain are thrown out</li>
</ul>
<p>With deadline propagation:</p>
<ul>
<li><b>A</b> sends a deadline to <b>B</b>, according to which <b>B</b> has 8 seconds left</li>
<li><b>B</b> computes something for 8 seconds</li>
<li><b>B</b> interrupts pointless request processing, the end</li>
</ul>
<p>See also <a href="https://sre.google/sre-book/addressing-cascading-failures">Google's guide</a>.</p>
<h2><a class="anchor" id="autotoc_md160"></a>
Why doesn't "close propagation" work</h2>
<p><code>A -&gt; B -&gt; C</code></p>
<p>How canceling requests through connection closure would supposedly work:</p>
<ul>
<li>on the timeout in <b>A</b>, it breaks the connection with <b>B</b></li>
<li>this cancels the request task in <b>B</b></li>
<li>this cancels the request to the client and breaks the connection with <b>C</b></li>
<li>this cancels the request task in <b>C</b></li>
</ul>
<p>In practice, it won't work that way:</p>
<ul>
<li>closing and reopening connections is expensive; we try to keep connections and send a stream of requests through them as long as possible</li>
<li>closing the client connection may be disabled by proxies like nginx, the client will not know about the cancellation in the calling service</li>
<li>"close propagation" is not instantaneous, it can take a long time to get from <b>A</b> to <b>C</b></li>
</ul>
<h2><a class="anchor" id="autotoc_md161"></a>
How it works in userver</h2>
<p>In HTTP, we use custom headers, as described below.</p>
<p>In gRPC, we use the built-in deadline mechanism based on the <code>grpc-timeout</code> header.</p>
<p>Database clients use timeout fields specific for them.</p>
<p><b>Summary:</b></p>
<ul>
<li>In the client that initiates the request chain:<ul>
<li>Set the deadline header based on the timeout value, initiating the deadline propagation process</li>
</ul>
</li>
<li>In handlers:<ul>
<li>Set the task-inherited deadline from the header</li>
<li>If deadline expires by the end of handling, replace the response with a special "Deadline expired" response</li>
</ul>
</li>
<li>In clients:<ul>
<li>Immediately return an error if the deadline has already expired</li>
<li>Use the task-inherited deadline to update the timeout</li>
<li>Propagate the deadline further as a header</li>
</ul>
</li>
<li>In database clients:<ul>
<li>Stop waiting for a free connection and immediately return an error if the deadline has already expired</li>
<li>Use task-inherited deadline to update the timeout</li>
<li>Include the deadline in the database query</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md162"></a>
Why is <code>duration</code> passed and not <code>time_point</code></h2>
<p>The engine uses a deadline (i.e. <code>time_point</code>) to measure time, and it is transmitted between hosts as a timeout (i.e. <code>duration</code>). This approach has the drawback it does not take into account RTT between services.</p>
<p>The decision to transmit the <code>duration</code> was made based on the fact that the clocks may not be synchronized accurately enough between hosts. In case of an unfortunate combination of circumstances, the service may reject the request prematurely. This problem especially affects requests with small timeouts.</p>
<h2><a class="anchor" id="autotoc_md163"></a>
Deadline Propagation HTTP headers</h2>
<p>The deadline propagation mechanism in userver uses custom headers.</p>
<p>What follows are the minimum semantic requirements for services that interact with userver-based services over HTTP to support deadline propagation.</p>
<ol type="1">
<li><code>X-YaTaxi-Client-TimeoutMs</code><ul>
<li>The client sends this header in the request, indicating the deadline for the called service</li>
<li>The deadline for the called service may be the same or be less than the deadline for the calling service</li>
</ul>
</li>
<li><code>X-YaTaxi-Deadline-Expired: &lt;any non-empty value&gt;</code><ul>
<li>The server includes this header in the response if the request could not be processed before the deadline from header (1)</li>
<li>This header must follow an HTTP status code in the range 400-599</li>
<li>In some cases, such a response may be sent before the actual deadline, if the server estimates that it is unable to respond in time before the specified deadline</li>
<li>When receiving such a response, the HTTP client in the calling service should process it as follows:<ul>
<li>Process such a response like timeouts or cancellations, discard the response body</li>
<li>If the request was made using the entire remainder of the calling service's deadline:<ul>
<li>Do not retry (regardless of the received HTTP status code)</li>
<li>The current handler should itself answer <code>Deadline expired</code></li>
</ul>
</li>
<li>If the request was NOT made using the entire remainder of the calling service's deadline:<ul>
<li>Interpret the response like a typical timeout (regardless of the received HTTP status code and body)</li>
<li>Apply the rules for retrying a timeout</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md164"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md165"></a>
Blocking the deadline propagation</h2>
<p>Task-inherited deadline is by default propagated from the handler task to child tasks created via <code>utils::*Async*</code>. There it is used in all clients that support it. This is implemented via <code><a class="el" href="../../d9/df8/namespaceserver_1_1request.html#a4a92ea288fda2b5ebb33345b49673a1c">server::request::kTaskInheritedData</a></code> and <code><a class="el" href="../../d9/df8/namespaceserver_1_1request.html#a71599441ee9180e5ba2f2ea81ddd48d4" title="Returns TaskInheritedData::deadline, or an unreachable engine::Deadline if none was set.">server::request::GetTaskInheritedDeadline</a></code>.</p>
<p>In <em>background tasks</em> that are started from the task of the request, but do not affect its completion, the deadline should not be propagated from the request tasks. Blocking such deadline propagation can be achieved by the following mechanisms:</p>
<ul>
<li><code><a class="el" href="../../d0/dc7/classconcurrent_1_1BackgroundTaskStorage.html#a063fec8b567f7b989dc2c7e9910115ff" title="Launch a task that will be cancelled and waited for in the BTS destructor.">concurrent::BackgroundTaskStorage::AsyncDetach</a></code></li>
<li><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gaa62af0c792f9f807a8667c0471dbf448">utils::AsyncBackground</a></code></li>
<li><code><a class="el" href="../../dc/d3f/namespaceengine.html#ac249644dedd4351b50adc96c8b76c358" title="Runs an asynchronous function call using specified task processor.">engine::AsyncNoSpan</a></code> (don't use it if you are not sure that you need it!)</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>when creating background tasks via <code><a class="el" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a></code> (instead of <code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gaa62af0c792f9f807a8667c0471dbf448">utils::AsyncBackground</a></code>), requests performed in them will be interrupted along with the parent task**</dd></dl>
<p>In some cases, it makes sense to ignore the inherited deadline and complete the request, even if no one is waiting for response from the current handle. To do this, make such a request in the scope of a <code><a class="el" href="../../dd/d26/classserver_1_1request_1_1DeadlinePropagationBlocker.html" title="Stops deadline propagation within its scope.">server::request::DeadlinePropagationBlocker</a></code>.</p>
<h1><a class="anchor" id="autotoc_md166"></a>
Deadline propagation details for HTTP handlers</h1>
<p>If there is a header <code>X-YaTaxi-Client-timeoutMs</code> in the request, the handler:</p>
<ul>
<li>Sets <code><a class="el" href="../../d3/d73/structserver_1_1request_1_1TaskInheritedData.html#a8e603b68d705dff633e5cf9d1db03e16" title="The time when there is no use handling the request anymore.">server::request::TaskInheritedData::deadline</a></code>, which is then used in clients</li>
<li>If the deadline has expired by the time the handler returns, then:<ul>
<li>the code <code>498 Deadline Expired</code> is returned;<ul>
<li>this code can be configured, see below;</li>
</ul>
</li>
<li>the body is <code>Deadline expired</code>.</li>
</ul>
</li>
<li>If by the time the request has been read to the end and the request has started to be processed, the deadline has already expired, then the user code is never called, and the handler responds as shown above</li>
</ul>
<h2><a class="anchor" id="autotoc_md167"></a>
Monitoring</h2>
<p>Metrics:</p>
<ul>
<li><code>deadline-received</code> (monotonic counter) - counts requests that have a deadline specified;</li>
<li><code>cancelled-by-deadline</code> (monotonic counter) - counts requests the handling of which was cancelled by deadline (deadline expired by the end of handling, or some operation estimated that the deadline would surely expire).</li>
</ul>
<p>Log tags of the request's <code><a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a></code>:</p>
<ul>
<li><code>deadline_received_ms=...</code> if the calling service has set a deadline for the request</li>
<li>if deadline expired while handling the request:<ul>
<li><code>cancelled_by_deadline=1</code>;</li>
<li><code>dp_original_body</code> - the user-provided response body (if any) that was replaced by <code>Deadline expired</code>;</li>
<li><code>dp_original_body_size</code> - the size of this body in bytes.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md168"></a>
Configuring</h2>
<p>To disable deadline propagation in the static config:</p>
<ul>
<li><code>server.listener.handler-defaults.deadline_propagation_enabled: false</code></li>
<li>or per handler: <code>&lt;handle component&gt;.deadline_propagation_enabled: false</code></li>
</ul>
<p>To disable deadline propagation in the dynamic config:</p>
<ul>
<li>set <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html#USERVER_DEADLINE_PROPAGATION_ENABLED">USERVER_DEADLINE_PROPAGATION_ENABLED</a> to <code>false</code></li>
</ul>
<p>The default HTTP status code for <code>Deadline expired</code> responses is a custom userver-specific <code>498 Deadline Expired</code> code. The code is deliberately chosen in the 4xx range, because it is not a server error by itself. Given infinite time, the server would probably handle the request successfully. However, some environments may fail to handle a non-standard code, in which case you may want to configure it.</p>
<p>To configure HTTP status code for <code>Deadline expired</code> responses:</p>
<ul>
<li><code>server.listener.handler-defaults.deadline_expired_status_code: 504</code></li>
<li>or per handler: <code>&lt;handle component&gt;.deadline_expired_status_code: 504</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md169"></a>
Deadline propagation details for gRPC service implementations</h1>
<p>The mechanism works similar to HTTP handlers. The deadline set in the context of the gRPC client is automatically passed to the context of the gRPC service. If there is a deadline:</p>
<ul>
<li>Sets task-inherited deadline, which is then used in clients.</li>
</ul>
<p>If the deadline has already expired by the time the request is processed, then:</p>
<ul>
<li>Request processing is interrupted;</li>
<li>The response <code>grpc::statusCode::DEADLINE_EXCEEDED</code> is returned with the message <code>Deadline propagation: Not enough time to handle this call</code>.</li>
</ul>
<p>Checking the deadline when performing streaming <code>Read</code> or <code>Write</code> operations is not yet implemented.</p>
<h2><a class="anchor" id="autotoc_md170"></a>
Monitoring</h2>
<p>Metrics:</p>
<ul>
<li><code>grpc.server.by-destination.deadline-propagated {grpc_destination=SERVICE_NAME/METHOD_NAME}</code> (RATE) - counts calls with a set deadline;</li>
<li><code>grpc.server.by-destination.cancelled-by-deadline-propagation {grpc_destination=SERVICE_NAME/METHOD_NAME}</code> (RATE) - counts calls for which the RPC was canceled by deadline.</li>
</ul>
<p>Log tags of the request's <code><a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a></code>:</p>
<ul>
<li><code>deadline_received_ms=...</code> if the calling client has set a deadline for the request (deadlines over a year are not taken into account);</li>
<li><code>cancelled_by_deadline=1</code> if the request processing was interrupted by the deadline.</li>
</ul>
<h2><a class="anchor" id="autotoc_md171"></a>
Configuring</h2>
<p>To disable deadline propagation in the static config:</p>
<ul>
<li>remove <code>deadline_propagation</code> from the list of <code>middlewares</code> of components of services</li>
</ul>
<p>To disable deadline propagation in the dynamic config:</p>
<ul>
<li>set <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html#USERVER_DEADLINE_PROPAGATION_ENABLED">USERVER_DEADLINE_PROPAGATION_ENABLED</a> to <code>false</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md172"></a>
Deadline propagation details for the HTTP client</h1>
<p>If there is a task-inherited deadline, the client:</p>
<ol type="1">
<li>Uses it as the upper limit of the timeout, in addition to the standard timeout setting</li>
<li>If the deadline has already expired, the client immediately throws <code><a class="el" href="../../d0/dda/classclients_1_1http_1_1CancelException.html">clients::http::CancelException</a></code></li>
<li>Sets the request header <code>X-YaTaxi-Client-TimeoutMs</code> from the timeout (regardless of whether it was decreased through deadline propagation)</li>
<li>If the task-inherited deadline was reached while working with the request, then:<ul>
<li>gives the user code <code><a class="el" href="../../d0/dda/classclients_1_1http_1_1CancelException.html">clients::http::CancelException</a></code></li>
<li>in the background, it waits for a response up to the standard timeout to try to save the connection</li>
<li>sends <code><a class="el" href="../../da/d84/classserver_1_1request_1_1DeadlineSignal.html" title="Signals when an operation has detected deadline expiration.">server::request::DeadlineSignal</a></code> to the current handle that we cancelled the request because of DP</li>
</ul>
</li>
<li>Otherwise, if the response has <code>X-YaTaxi-Deadline-Expired</code> header, it converts the response to <code><a class="el" href="../../d8/de6/classclients_1_1http_1_1TimeoutException.html">clients::http::TimeoutException</a></code></li>
</ol>
<h2><a class="anchor" id="autotoc_md173"></a>
Monitoring</h2>
<p>Metrics:</p>
<ul>
<li><code>timeout-updated-by-deadline</code> (monotonic counter) - counts requests for which the deadline was set and affected the timeout (while the request was not necessarily canceled by the deadline)</li>
<li><code>cancelled-by-deadline</code> (monotonic counter) - counts requests which was cancelled by the task-inherited deadline</li>
</ul>
<p>Log tags of the request's <code><a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a></code>:</p>
<ul>
<li><code>propagated_timeout_ms</code> - if the deadline was set and affected the timeout (while the request was not necessarily canceled by the deadline)</li>
<li><code>cancelled_by_deadline=1</code> - if the request was canceled by the task-inherited deadline</li>
</ul>
<h2><a class="anchor" id="autotoc_md174"></a>
Configuring</h2>
<p>To disable deadline propagation in the static config:</p>
<ul>
<li><code>http-client.set-deadline-propagation-header: false</code></li>
<li>timeouts are updated from the task-inherited deadline regardless of this config</li>
</ul>
<p>To disable deadline propagation in the dynamic config:</p>
<ul>
<li>set <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html#USERVER_DEADLINE_PROPAGATION_ENABLED">USERVER_DEADLINE_PROPAGATION_ENABLED</a> to <code>false</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md175"></a>
Deadline propagation details for gRPC clients</h1>
<p>If there is a task-inherited deadline, the client uses it as an upper bound for the built-in RPC deadline as implemented by grpc++.</p>
<h2><a class="anchor" id="autotoc_md176"></a>
Monitoring</h2>
<p>Metrics:</p>
<ul>
<li><code>grpc.client.by-destination.deadline-propagated {grpc_destination=SERVICE_NAME/METHOD_NAME}</code> (RATE) - RPCs for which the original deadline was overridden by the propagated deadline (while the request was not necessarily canceled by deadline);</li>
<li><code>grpc.client.by-destination.cancelled-by-deadline-propagation {grpc_destination=SERVICE_NAME/METHOD_NAME}</code> (RATE) - RPCs that were canceled due to the propagated deadline.</li>
</ul>
<p>Request span Tags:</p>
<ul>
<li><code>deadline_updated=1</code> - if the RPC deadline was overridden by the task-inherited deadline;</li>
<li><code>timeout_ms=...</code> - the final deadline value, represented as a timeout.</li>
</ul>
<h2><a class="anchor" id="autotoc_md177"></a>
Configuring</h2>
<p>To disable deadline propagation in the static config:</p>
<ul>
<li>remove <code>deadline_propagation</code> from the list of <code>middlewares</code> of components of gRPC services or clients</li>
</ul>
<p>To disable deadline propagation in the dynamic config:</p>
<ul>
<li>set <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html#USERVER_DEADLINE_PROPAGATION_ENABLED">USERVER_DEADLINE_PROPAGATION_ENABLED</a> to <code>false</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md178"></a>
Deadline propagation details for Mongo</h1>
<ol type="1">
<li>If the deadline has expired at the start of the request to mongo, or expired before a free connection appears, <code>stores::mongo::CancelledException</code> is thrown</li>
<li>If <code>maxTimeMS</code> is not set or is less strict than the deadline, then <code>maxTimeMS</code> is updated<ul>
<li>If the request times out after that, then the usual mongo timeout exception is thrown (<code>stores::mongo::ClusterUnavailableException</code>)</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md179"></a>
Monitoring</h2>
<p>If the deadline has expired before the request is actually sent, then:</p>
<ul>
<li>metrics indicate error type <code>cancelled</code></li>
<li>logs include the tag <code>cancelled_by_deadline=true</code></li>
</ul>
<p>If the request is sent with deadline propagation enabled, then:</p>
<ul>
<li>the tag <code>timeout_ms</code> is included in the log - it is the time remaining until the deadline expires at the request initiation<ul>
<li>this time includes the time spent waiting for a free connection (if any)</li>
</ul>
</li>
<li>the tag <code>max_time_ms</code> is included in the log - it corresponds to the value of <code>maxTimeMS</code> (only included for those request types where <code>maxTimeMs</code> is allowed)</li>
</ul>
<h1><a class="anchor" id="autotoc_md180"></a>
Deadline propagation details for Postgres</h1>
<ol type="1">
<li>If the deadline has expired before the start of <code>Execute</code>, the exception <code>stores::postgres::ConnectionInterrupted</code> is thrown</li>
<li>The request timeout is not updated from the deadline <b>TODO</b></li>
</ol>
<h1><a class="anchor" id="autotoc_md181"></a>
Deadline propagation details for Redis</h1>
<ol type="1">
<li>If the deadline has expired at the start of the request, <code>redis::RequestException</code> is thrown with <code>GetStatus() == redis::ReplyStatus::kTimeoutError</code></li>
<li>The request timeout is updated from the deadline<ul>
<li>If the request is delayed after that, then the usual redis timeout exception is thrown: <code>redis::RequestException</code> with <code>GetStatus() == redis::ReplyStatus::kTimeoutError</code></li>
</ul>
</li>
</ol>
<hr  />
<p> <div class="bottom-nav">  ⇦ <a class="el" href="../../df/d4e/md_en_2userver_2os__signals.html">Handling OS signals</a> | <a class="el" href="../../d0/d44/md_en_2userver_2congestion__control.html">Congestion Control</a> ⇨  </div>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:55:58 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
