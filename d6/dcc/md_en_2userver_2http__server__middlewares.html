<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Http server middlewares</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/dcc/md_en_2userver_2http__server__middlewares.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Http server middlewares</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md325"></a> </p>
<h1><a class="anchor" id="autotoc_md326"></a>
Introduction</h1>
<p>Middleware is software that's assembled into an app pipeline to handle requests and responses. Each component:</p>
<ul>
<li>Chooses whether to pass the request to the next component in the pipeline.</li>
<li>Can perform work before and after the next component in the pipeline.</li>
</ul>
<p>üêô <b>userver</b> provides interfaces to implement these pipeline pieces and to configure them as well as the resulting pipeline for the http server. The general idea behind middlewares is no different from that in other web-frameworks like <a href="https://docs.djangoproject.com/en/5.0/topics/http/middleware/">Django</a>, <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0/">ASP.NET Core</a>, <a href="https://gin-gonic.com/docs/examples/custom-middleware/">Gin</a>, <a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/interceptors.html">Spring</a>, <a href="https://docs.rs/axum/latest/axum/middleware/index.html">Axum</a> etc., but the exact implementation details differ here and there.</p>
<p>If you've already made yourself familiar with how middlewares are implemented in üêô <b>userver</b> you may want to skip straight to <a class="el" href="#middlewares_usage_and_configuration">Usage and configuration</a>.</p>
<h1><a class="anchor" id="autotoc_md327"></a>
High level design</h1>
<p>Every http request handled by the <a class="el" href="../../d0/d0b/classcomponents_1_1Server.html" title="Component that listens for incoming requests, manages incoming connections and passes the requests to...">components::Server</a> is processed in a number of steps:</p>
<ol type="1">
<li>The request is parsed from the byte stream coming from a network connection</li>
<li>The request is traced, accounted for, decompressed/rate-limited/authorized/etc if needed, parsed into application-requested format (say, JSON), logged if configured to do so, and a bunch of other steps</li>
<li>The request is routed into corresponding <a class="el" href="../../d6/d36/classserver_1_1handlers_1_1HttpHandlerBase.html" title="Base class for all the Userver HTTP Handlers.">server::handlers::HttpHandlerBase</a></li>
<li>The response created by the handler is traced, accounted for, logged if configured to do so... you get the idea</li>
<li>The response is serialized into byte stream and sent to the wire</li>
</ol>
<p>Steps 2. and 4. are implemented by a number of logically-independent middlewares, which allows us to tune/enhance/rearrange things without going into massive refactoring, and allows our users to adjust the pipeline as they see fit.</p>
<p>An important detail of the middlewares implementation is that technically middleware is not a <a class="el" href="../../dc/dcc/md_en_2userver_2component__system.html">Component</a>, but rather a <a class="el" href="../../de/d08/group__userver__clients.html">Client</a>: given M middlewares and H handlers, there will be M x H instances of middlewares in total, M instances for each handler. Such arguably more complicated approach is justified by the configurability-freedom it provides: instead of somehow adjusting the middleware behavior in the code (based on a route, for example), one can configure the middleware at per-handler basis in exactly the same way most things in userver are configured: by a static config.</p>
<p>Middlewares very well might want to interact with the component system of userver, be that for sharing some common resource (say, global rate-limiting) or for performing database/http queries. Since a middleware is not a component, it doesn't have a way to lookup it's dependencies from the <a class="el" href="../../da/db1/classcomponents_1_1ComponentContext.html">components::ComponentContext</a> itself, but rather the dependencies should be injected into a middleware instance. This is where a MiddlewareFactory comes into play.</p>
<p>Every <a class="el" href="../../d0/daa/classserver_1_1middlewares_1_1HttpMiddlewareBase.html">Middleware</a> is paired with a corresponding <a class="el" href="../../dd/d90/classserver_1_1middlewares_1_1HttpMiddlewareFactoryBase.html">Factory</a>, which is a Component, and is responsible for creating middleware instances and injecting required dependencies into these instances. It goes like this: when a handler is constructed, it looks up all the factories specified by the pipeline configuration, requests each factory to create a middleware instance, and then builds the resulting pipeline from these instances. So, to emphasize once again: a Middleware instance is not a Component but rather a Client, and there might be multiple instances of the same Middleware type, but a MiddlewareFactory is a Component, hence is a singleton.</p>
<p>For reference, this is the userver-provided default middlewares pipeline: </p><div class="fragment"><div class="line">MiddlewaresList <a class="code hl_function" href="../../d7/d58/group__userver__middlewares.html#gab807835c4b2b4e6af4f38b383bc87468" title="Returns the default userver-provided middleware pipeline.">DefaultPipeline</a>() {</div>
<div class="line">    <span class="keywordflow">return</span> {</div>
<div class="line">        <span class="comment">// Metrics should go before everything else, basically.</span></div>
<div class="line">        std::string{builtin::kHandlerMetrics},</div>
<div class="line">        <span class="comment">// Tracing should go before UnknownExceptionsHandlingMiddleware because it</span></div>
<div class="line">        <span class="comment">// adds some headers, which otherwise might be cleared</span></div>
<div class="line">        std::string{builtin::kTracing},</div>
<div class="line">        <span class="comment">// Ditto</span></div>
<div class="line">        std::string{builtin::kSetAcceptEncoding},</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Every exception caught here is transformed into Http500 without</span></div>
<div class="line">        <span class="comment">// context.</span></div>
<div class="line">        <span class="comment">// All middlewares except for the most obscure ones should go below.</span></div>
<div class="line">        std::string{builtin::kUnknownExceptionsHandling},</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Should be self-explanatory</span></div>
<div class="line">        std::string{builtin::kRateLimit},</div>
<div class="line">        std::string{builtin::kBaggage},</div>
<div class="line">        std::string{builtin::kAuth},</div>
<div class="line">        std::string{builtin::kDecompression},</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Transforms CustomHandlerException into response as specified by the</span></div>
<div class="line">        <span class="comment">// exception, transforms std::exception into Http500 without context.</span></div>
<div class="line">        <span class="comment">// Middlewares that throw CustomHandlerException on error should go below.</span></div>
<div class="line">        <span class="comment">// Middlewares that call HttpHandlerBase::HandleCustomHandlerException or</span></div>
<div class="line">        <span class="comment">// fill the response manually on error (which is faster) should go above.</span></div>
<div class="line">        std::string{builtin::kExceptionsHandling},</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// DeadlinePropagation should go after ExceptionsHandlingMiddleware</span></div>
<div class="line">        <span class="comment">// if the request threw an std::exception and was canceled by deadline</span></div>
<div class="line">        <span class="comment">// propagation,</span></div>
<div class="line">        <span class="comment">// then it must be handled differently.</span></div>
<div class="line">        std::string{builtin::kDeadlinePropagation},</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md328"></a>
Caveats</h1>
<p>In general, one should be very careful when modifying the response after the downstream part of the pipeline completed, and the reason for that is simple: the modification could be overwritten by the upstream part. This is especially apparent when exceptions are involved: consider the case when an exception is propagating through the pipeline, and a middleware is adding a header to the response. Depending on the exception type and where in the pipeline middleware is put, the header may or may not be overridden by the ExceptionsHandling middleware.</p>
<p>Due to this, response-modifying middlewares should be either put before ExceptionsHandling middleware for their changes to reliably take effect if the downstream pipeline threw, or a middleware should handle downstream exceptions itself. Middlewares also should never throw on their own: it's ok to let the downstream exception pass through, but throwing from the middlewares logic could lead to some nonsensical responses being sent to the client, up to violating the http specification.</p>
<p>The default userver-provided middlewares pipeline handles all these cases and is guaranteed to still have all the tracing headers and a meaningful status code (500, likely) present for the response even if the user-built part of the middleware pipeline threw some random exception, but if you reorder or hijack the default pipeline, you are on your own.</p>
<p><a class="anchor" id="middlewares_usage_and_configuration"></a></p>
<h1><a class="anchor" id="autotoc_md329"></a>
Usage and configuration</h1>
<p>This is how a minimal implementation of a middleware looks like: </p><div class="fragment"><div class="line"><span class="keyword">class </span>NoopMiddleware final : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/daa/classserver_1_1middlewares_1_1HttpMiddlewareBase.html" title="Base class for a http middleware.">server::middlewares::HttpMiddlewareBase</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> HandleRequest(<a class="code hl_class" href="../../d3/d44/classserver_1_1http_1_1HttpRequest.html" title="HTTP Request data.">server::http::HttpRequest</a>&amp; request, <a class="code hl_class" href="../../de/df6/classserver_1_1request_1_1RequestContext.html" title="Stores request-specific data during request processing.">server::request::RequestContext</a>&amp; context)<span class="keyword"> const override </span>{</div>
<div class="line">        Next(request, context);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> It doesn't have any logic in it and just passes the execution to the downstream. This is how a factory for this middleware looks: </p><div class="fragment"><div class="line"><span class="keyword">class </span>NoopMiddlewareFactory final : <span class="keyword">public</span> <a class="code hl_class" href="../../dd/d90/classserver_1_1middlewares_1_1HttpMiddlewareFactoryBase.html" title="Base class for a http middleware-factory.">server::middlewares::HttpMiddlewareFactoryBase</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::string_view kName{<span class="stringliteral">&quot;noop-middleware&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>HttpMiddlewareFactoryBase::HttpMiddlewareFactoryBase;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;server::middlewares::HttpMiddlewareBase&gt;</div>
<div class="line">    Create(<span class="keyword">const</span> <a class="code hl_class" href="../../d6/d36/classserver_1_1handlers_1_1HttpHandlerBase.html" title="Base class for all the Userver HTTP Handlers.">server::handlers::HttpHandlerBase</a>&amp;, <a class="code hl_class" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html" title="Datatype that represents YAML with substituted variables.">yaml_config::YamlConfig</a>)<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;NoopMiddleware&gt;();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> which feels too verbose for the amount of logic the code performs, so we have a shortcut version, which does the same and also passes the handler into the middleware constructor. Given the middleware that performs some logic </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeServerMiddleware final : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/daa/classserver_1_1middlewares_1_1HttpMiddlewareBase.html" title="Base class for a http middleware.">server::middlewares::HttpMiddlewareBase</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// This will be used as a kName for the SimpleHttpMiddlewareFactory</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::string_view kName{<span class="stringliteral">&quot;server-middleware&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Handler isn&#39;t interesting to us, but we could use it if needed.</span></div>
<div class="line">    <span class="comment">// Or we could implement the factory ourselves instead of using</span></div>
<div class="line">    <span class="comment">// SimpleHttpMiddlewareFactory, and pass whatever parameters we want.</span></div>
<div class="line">    <span class="keyword">explicit</span> SomeServerMiddleware(<span class="keyword">const</span> <a class="code hl_class" href="../../d6/d36/classserver_1_1handlers_1_1HttpHandlerBase.html" title="Base class for all the Userver HTTP Handlers.">server::handlers::HttpHandlerBase</a>&amp;) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> HandleRequest(<a class="code hl_class" href="../../d3/d44/classserver_1_1http_1_1HttpRequest.html" title="HTTP Request data.">server::http::HttpRequest</a>&amp; request, <a class="code hl_class" href="../../de/df6/classserver_1_1request_1_1RequestContext.html" title="Stores request-specific data during request processing.">server::request::RequestContext</a>&amp; context)<span class="keyword"> const override </span>{</div>
<div class="line">        Next(request, context);</div>
<div class="line">        request.<a class="code hl_function" href="../../d3/d44/classserver_1_1http_1_1HttpRequest.html#a2434ed4270f909f1b74224fbc4196aed" title="Returns a container that should be filled with response data to this request.">GetHttpResponse</a>().<a class="code hl_function" href="../../da/da4/classserver_1_1http_1_1HttpResponse.html#a4b125ab9ca9200fbe02f07c01466c007" title="Add a new response header or rewrite an existing one.">SetHeader</a>(kCustomServerHeader, <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_class" href="../../df/db9/classhttp_1_1headers_1_1PredefinedHeader.html" title="A struct to represent compile-time known header name.">http::headers::PredefinedHeader</a> kCustomServerHeader{<span class="stringliteral">&quot;X-Some-Server-Header&quot;</span>};</div>
<div class="line">};</div>
</div><!-- fragment --><p> the factory implementation is just this: </p><div class="fragment"></div><!-- fragment --><p> Do not forget to add components configs: </p><div class="fragment"><div class="line">        noop-middleware: {}</div>
<div class="line"> </div>
<div class="line">        server-middleware: {}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md330"></a>
Global middleware configuration</h2>
<p>Normally, the process of configuring a middleware is the same as configuring any other component, see <a class="el" href="../../dc/dcc/md_en_2userver_2component__system.html">Component system</a></p>
<p>As a component, a <code>MiddlewareFactory</code> takes <code>(config, context)</code> parameters in its constructor. It can parse some fields from <code>config</code> and store them in the component. Then it can pass this configuration (references are OK) to each <code>Middleware</code> created in its <a class="el" href="../../dd/d90/classserver_1_1middlewares_1_1HttpMiddlewareFactoryBase.html#a4c3304c06b0cbbe0ea59cb3203aa6811">Create</a> method.</p>
<p>All used config fields should be described in <code>MyMiddlewareFactory::GetStaticConfigSchema</code>.</p>
<p>Global configuration should be preferred to per-handler configuration, because the latter leads to copy-pasta in configs. For some options, it's a good idea to implement both global and per-handler configuration.</p>
<h2><a class="anchor" id="autotoc_md331"></a>
Per-handler middleware configuration</h2>
<p>Basically, the whole point of having MiddlewareFactory-ies separated from Middleware-s, is to have a possibility to configure a middleware at a per-handler basis. In the snippet above that's what "handler-middleware.header-value" is for: given the middleware (which actually resembles pretty close to how tracing headers are set to the response in userver) </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeHandlerMiddleware final : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/daa/classserver_1_1middlewares_1_1HttpMiddlewareBase.html" title="Base class for a http middleware.">server::middlewares::HttpMiddlewareBase</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::string_view kName{<span class="stringliteral">&quot;handler-middleware&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    SomeHandlerMiddleware(<span class="keyword">const</span> <a class="code hl_class" href="../../d6/d36/classserver_1_1handlers_1_1HttpHandlerBase.html" title="Base class for all the Userver HTTP Handlers.">server::handlers::HttpHandlerBase</a>&amp;, <a class="code hl_class" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html" title="Datatype that represents YAML with substituted variables.">yaml_config::YamlConfig</a> middleware_config)</div>
<div class="line">        : header_value_{middleware_config[<span class="stringliteral">&quot;header-value&quot;</span>].As&lt;<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html" title="STL namespace.">std</a>::string&gt;()} {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> HandleRequest(<a class="code hl_class" href="../../d3/d44/classserver_1_1http_1_1HttpRequest.html" title="HTTP Request data.">server::http::HttpRequest</a>&amp; request, <a class="code hl_class" href="../../de/df6/classserver_1_1request_1_1RequestContext.html" title="Stores request-specific data during request processing.">server::request::RequestContext</a>&amp; context)<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="comment">// We will set the header no matter whether downstream succeeded or not.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that in presence of exceptions other that</span></div>
<div class="line">        <span class="comment">// CustomHandlerException-derived ones, this header would be removed by</span></div>
<div class="line">        <span class="comment">// default userver-provided exceptions handling middleware. If this is</span></div>
<div class="line">        <span class="comment">// undesirable, the middleware should be earlier in the pipeline, or the</span></div>
<div class="line">        <span class="comment">// default exceptions handling behavior could be overridden.</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/d5e/classutils_1_1ScopeGuard.html" title="a helper class to perform actions on scope exit">utils::ScopeGuard</a> set_header_scope{</div>
<div class="line">            [<span class="keyword">this</span>, &amp;request] { request.<a class="code hl_function" href="../../d3/d44/classserver_1_1http_1_1HttpRequest.html#a2434ed4270f909f1b74224fbc4196aed" title="Returns a container that should be filled with response data to this request.">GetHttpResponse</a>().<a class="code hl_function" href="../../da/da4/classserver_1_1http_1_1HttpResponse.html#a4b125ab9ca9200fbe02f07c01466c007" title="Add a new response header or rewrite an existing one.">SetHeader</a>(kCustomHandlerHeader, header_value_); }};</div>
<div class="line"> </div>
<div class="line">        Next(request, context);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_class" href="../../df/db9/classhttp_1_1headers_1_1PredefinedHeader.html" title="A struct to represent compile-time known header name.">http::headers::PredefinedHeader</a> kCustomHandlerHeader{<span class="stringliteral">&quot;X-Some-Handler-Header&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string header_value_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> and the factory implementation </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeHandlerMiddlewareFactory final : <span class="keyword">public</span> <a class="code hl_class" href="../../dd/d90/classserver_1_1middlewares_1_1HttpMiddlewareFactoryBase.html" title="Base class for a http middleware-factory.">server::middlewares::HttpMiddlewareFactoryBase</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::string_view kName{SomeHandlerMiddleware::kName};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>HttpMiddlewareFactoryBase::HttpMiddlewareFactoryBase;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;server::middlewares::HttpMiddlewareBase&gt;</div>
<div class="line">    Create(<span class="keyword">const</span> <a class="code hl_class" href="../../d6/d36/classserver_1_1handlers_1_1HttpHandlerBase.html" title="Base class for all the Userver HTTP Handlers.">server::handlers::HttpHandlerBase</a>&amp; handler, <a class="code hl_class" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html" title="Datatype that represents YAML with substituted variables.">yaml_config::YamlConfig</a> middleware_config)<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;SomeHandlerMiddleware&gt;(handler, std::move(middleware_config));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="../../d1/d3e/structyaml__config_1_1Schema.html" title="JSON Schema-like type definition.">yaml_config::Schema</a> GetMiddlewareConfigSchema()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_function" href="../../d7/d72/namespaceformats_1_1yaml.html#adaade9466d62f79f127e112bead15081" title="Parse YAML from string.">formats::yaml::FromString</a>(R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">type: object</span></div>
<div class="line"><span class="stringliteral">description: Config for this particular middleware</span></div>
<div class="line"><span class="stringliteral">additionalProperties: false</span></div>
<div class="line"><span class="stringliteral">properties:</span></div>
<div class="line"><span class="stringliteral">    header-value:</span></div>
<div class="line"><span class="stringliteral">        type: string</span></div>
<div class="line"><span class="stringliteral">        description: header value to set for responses</span></div>
<div class="line"><span class="stringliteral">)&quot;)</span></div>
<div class="line"><span class="stringliteral">            .<a class="code hl_function" href="../../da/dc1/classformats_1_1yaml_1_1Value.html#a5774473a4a3c8de6fa87de77523b52a0" title="Returns value of *this converted to the result type of Parse(const Value&amp;, parse::To&lt;T&gt;)....">As</a>&lt;<a class="code hl_struct" href="../../d1/d3e/structyaml__config_1_1Schema.html" title="JSON Schema-like type definition.">yaml_config::Schema</a>&gt;();</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">};</span></div>
</div><!-- fragment --><p> one can configure the middleware behavior (header value, in this particular case) in the handler's static config.</p>
<p>If a global configuration is desired (that is, for every middleware instance there is), the easiest way to achieve that would be to have a configuration in the Factory config, and for Factory to pass the configuration into the Middleware constructor. This takes away the possibility to declare a Factory as a SimpleHttpMiddlewareFactory, but we find this tradeoff acceptable (after all, if a middleware needs a configuration it isn't that "Simple" already).</p>
<p>Do not forget to add components configs: </p><div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="autotoc_md332"></a>
Pipelines configuration</h1>
<p>Now, after we have a middleware and its factory implemented, it would be nice to actually use the middleware in the pipeline. üêô <b>userver</b> provides two interfaces for configuring middleware pipelines: one for a server-wide configuration, and one for a more granular per-handler configuration.</p>
<h2><a class="anchor" id="autotoc_md333"></a>
Server-wide middleware pipeline</h2>
<p>The server-wide pipeline is <a class="el" href="../../df/db8/classserver_1_1middlewares_1_1PipelineBuilder.html" title="Base class to build a server-wide middleware pipeline. One may inherit from it and implement any cust...">server::middlewares::PipelineBuilder</a>. In its simple form, it takes <a class="el" href="../../d7/d58/group__userver__middlewares.html#gab807835c4b2b4e6af4f38b383bc87468" title="Returns the default userver-provided middleware pipeline.">server::middlewares::DefaultPipeline</a> and appends the given middlewares to it, which looks like this: </p><div class="fragment"><div class="line">        # yaml</div>
<div class="line">        default-server-middleware-pipeline-builder:</div>
<div class="line">            append:</div>
<div class="line">              - server-middleware     # Or we could implement the same in the code, consider it a shortcut.</div>
</div><!-- fragment --><p>If a more sophisticated behavior is desired, derive from <a class="el" href="../../df/db8/classserver_1_1middlewares_1_1PipelineBuilder.html" title="Base class to build a server-wide middleware pipeline. One may inherit from it and implement any cust...">server::middlewares::PipelineBuilder</a> and override its <code>BuildPipeline</code> method. Then set the custom pipeline component's name in the config of <a class="el" href="../../d0/d0b/classcomponents_1_1Server.html" title="Component that listens for incoming requests, manages incoming connections and passes the requests to...">components::Server</a>:</p>
<div class="fragment"><div class="line"># yaml</div>
<div class="line">        server:</div>
<div class="line">            # ...</div>
<div class="line">            middleware-pipeline-builder: custom-pipeline-builder</div>
</div><!-- fragment --><p>Remember that messing with the default userver-provided pipeline is error-prone and leaves you on your own.</p>
<h2><a class="anchor" id="autotoc_md334"></a>
Custom per-handler middleware pipelines</h2>
<p>To configure the pipeline at a per-handler basis üêô <b>userver</b> provides <a class="el" href="../../d1/dbd/classserver_1_1middlewares_1_1HandlerPipelineBuilder.html" title="Base class to build a per-handler middleware pipeline. One may inherit from it and implement any cust...">server::middlewares::HandlerPipelineBuilder</a> interface. By default, it returns the server-wide pipeline without any modifications to it. To change the behavior one should derive from it, override the <code>BuildPipeline</code> method and specify the builder as the pipeline-builder for the handler. For example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>CustomHandlerPipelineBuilder final : <span class="keyword">public</span> <a class="code hl_class" href="../../d1/dbd/classserver_1_1middlewares_1_1HandlerPipelineBuilder.html" title="Base class to build a per-handler middleware pipeline. One may inherit from it and implement any cust...">server::middlewares::HandlerPipelineBuilder</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>HandlerPipelineBuilder::HandlerPipelineBuilder;</div>
<div class="line"> </div>
<div class="line">    server::middlewares::MiddlewaresList BuildPipeline(server::middlewares::MiddlewaresList server_middleware_pipeline</div>
<div class="line">    )<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="comment">// We could do any kind of transformation here.</span></div>
<div class="line">        <span class="comment">// For the sake of example (and what we assume to be the most common case),</span></div>
<div class="line">        <span class="comment">// we just add some middleware to the pipeline.</span></div>
<div class="line">        <span class="keyword">auto</span>&amp; pipeline = server_middleware_pipeline;</div>
<div class="line">        pipeline.emplace_back(SomeHandlerMiddleware::kName);</div>
<div class="line">        pipeline.emplace_back(NoopMiddlewareFactory::kName);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> pipeline;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> and to use the class as a pipeline builder we should append it to the <a class="el" href="../../dc/df0/classcomponents_1_1ComponentList.html">ComponentList</a> </p><div class="fragment"><div class="line">          .Append&lt;samples::http_middlewares::CustomHandlerPipelineBuilder&gt;(</div>
<div class="line">              <span class="stringliteral">&quot;custom-handler-pipeline-builder&quot;</span>)</div>
</div><!-- fragment --><p> and specify as a pipeline-builder for the handler (notice the middlewares.pipeline-builder section): </p><div class="fragment"><div class="line">        # yaml</div>
<div class="line">        handler-with-custom-middlewares:</div>
<div class="line">            path: /custom-hello</div>
<div class="line">            method: GET</div>
<div class="line">            task_processor: main-task-processor</div>
<div class="line">            middlewares:</div>
<div class="line">                pipeline-builder: custom-handler-pipeline-builder</div>
<div class="line">                handler-middleware:</div>
<div class="line">                    header-value: some_value</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:55:59 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
