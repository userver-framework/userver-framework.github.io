<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Synchronization Primitives</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d6c/md_en_2userver_2synchronization.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Synchronization Primitives</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md540"></a> This page describes the synchronization mechanisms that are available in userver, their advantages and weaknesses. It is assumed that the developer is aware of concurrent programming and concepts like "race", "critical section", "mutex".</p>
<h1><a class="anchor" id="autotoc_md541"></a>
Constraint</h1>
<p>‚ö†Ô∏èüêô‚ùó Use of the C++ standard library and libc synchronization primitives in coroutines <b>is forbidden</b>.</p>
<h1><a class="anchor" id="autotoc_md542"></a>
Cancellations, Cancellation Blockers and Synchronization Primitives</h1>
<p>Different synchronization primitives treat task cancellations differently. Some may ignore cancellations, others return early without acquiring the resource.</p>
<p>Many synchronization primitives ignore cancellation requests as such default seems to provoke less issues in code that uses the primitive. For example <a class="el" href="../../d0/da4/classengine_1_1Mutex.html#a1345db9a141f510dc5941e584bd4408c">engine::Mutex::lock()</a> ignores cancellation requests as it has no way to report failure other than by throwing an exception, and throwing an exception may not be expected by users and could lead to std::terminate().</p>
<p>Read the documentation on particular primitive to get the behavior on task cancellation. The cancellation could be <b>blocked</b> by <a class="el" href="../../df/d40/classengine_1_1TaskCancellationBlocker.html">engine::TaskCancellationBlocker</a>, so the latter could be used to force the primitive to ignore the cancellation request. <br  />
</p>
<p>See also: <a class="el" href="../../d8/d00/md_en_2userver_2intro.html#task_cancellation_intro">task_cancellation_intro</a></p>
<h1><a class="anchor" id="autotoc_md543"></a>
Synchronization mechanisms and primitives</h1>
<p>This section describes the major available synchronization mechanisms with use cases. All the primitives are listed at the <a class="el" href="../../dc/db7/group__userver__concurrency.html">Concurrency</a> API Group.</p>
<dl class="section note"><dt>Note</dt><dd>There is no "faster" synchronization mechanism. Different primitives are suitable for different situations. For some load profile primitive A could be 1000 times faster than primitive B. For another - exactly the opposite. Before choosing a primitive, determinate the load profile (how often does reading and writing occur, how many concurrent writers/readers are there etc). For a practical assessment of the effectiveness of a particular tool for your case, use <a href="https://github.com/google/benchmark">google benchmark</a> and stress testing.</dd></dl>
<h2><a class="anchor" id="autotoc_md544"></a>
engine::TaskWithResult</h2>
<p>For parallel independent calculations the simplest, and most reliable way to transmit data is through the result of the <a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> execution.</p>
<div class="fragment"><div class="line">    std::vector&lt;engine::TaskWithResult&lt;int&gt;&gt; tasks;</div>
<div class="line">    tasks.reserve(container.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : container) {</div>
<div class="line">        <span class="comment">// Creating tasks that will be executed in parallel</span></div>
<div class="line">        tasks.push_back(<a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;some_task&quot;</span>, [value = std::move(value)] {</div>
<div class="line">            <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#a19462f750672c6fa7f5f690c2575b9f6">engine::InterruptibleSleepFor</a>(std::chrono::milliseconds(100));</div>
<div class="line">            <span class="keywordflow">return</span> value;</div>
<div class="line">        }));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// we wait for the completion of tasks and get the results</span></div>
<div class="line">    std::vector&lt;int&gt; results;</div>
<div class="line">    results.reserve(tasks.size());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; task : tasks) {</div>
<div class="line">        <span class="comment">// If the task completed with an exception,</span></div>
<div class="line">        <span class="comment">// then Get () will throw an exception</span></div>
<div class="line">        results.push_back(task.Get());</div>
<div class="line">    }</div>
</div><!-- fragment --><p>A less convenient and more complicated way to solve the same problem is to create a data structure shared between tasks, where the tasks themselves will record the result. This requires protecting the data through atomic variables or <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">engine::Mutex</a>, as well as passing this data structure to the subtasks. In this case, <a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a> may be useful (see below).</p>
<p>Note that when programming tasks, you need to take into account the lifetime of objects. If you pass a closure to a task with a reference to a variable, then you must ensure that the lifetime of the task is strictly less than the lifetime of the variable. This must also be guaranteed for the case of throwing an exception from any function used. If this cannot be guaranteed, then either pass the data to the closure via shared_ptr, or pass it over the copy.</p>
<h2><a class="anchor" id="autotoc_md545"></a>
engine::Future</h2>
<p>Sometimes calculations could not decomposed easily and a single <a class="el" href="../../d8/d7c/classengine_1_1Task.html" title="Asynchronous task that has a unique ownership of the payload.">engine::Task</a> should return many results. At the same time, it is not efficient to collect them into one structure and return them at one (the results are used as inputs for several tasks, etc.). For such cases, you can use the <a class="el" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise</a> and <a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a>. They provide a synchronized channel for transmitting the value between tasks. The interface and contracts of these classes are as close as possible to similar types from the standard library. The main differences are related to the support for the cancellation mechanism.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise&lt;int&gt;</a> int_promise;</div>
<div class="line">    <a class="code hl_class" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise&lt;std::string&gt;</a> string_promise;</div>
<div class="line">    <span class="keyword">auto</span> deadline = GetDeadline();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kBadValue = -1;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kFallbackString = <span class="stringliteral">&quot;Bad string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kTestValue = 777;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;Test string value&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> int_future = int_promise.<a class="code hl_function" href="../../d9/d2e/classengine_1_1Promise.html#a70eab6f2622012a68684aa1a05c0fbdb">get_future</a>();</div>
<div class="line">    <span class="keyword">auto</span> string_future = string_promise.<a class="code hl_function" href="../../d9/d2e/classengine_1_1Promise.html#a70eab6f2622012a68684aa1a05c0fbdb">get_future</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> calc_task = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(</div>
<div class="line">        <span class="stringliteral">&quot;calc&quot;</span>,</div>
<div class="line">        [int_promise = std::move(int_promise), string_promise = std::move(string_promise), kTestValue]() <span class="keyword">mutable</span> {</div>
<div class="line">            <span class="comment">// Emulating long calculation of x and s...</span></div>
<div class="line">            <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#a3f0a331825dbd69a272a606b7d5006ed">engine::SleepFor</a>(100ms);</div>
<div class="line">            int_promise.<a class="code hl_function" href="../../d9/d2e/classengine_1_1Promise.html#afe9369eedca9868c41f689ff15799b98">set_value</a>(kTestValue);</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#a3f0a331825dbd69a272a606b7d5006ed">engine::SleepFor</a>(100ms);</div>
<div class="line">            string_promise.<a class="code hl_function" href="../../d9/d2e/classengine_1_1Promise.html#afe9369eedca9868c41f689ff15799b98">set_value</a>(kTestString);</div>
<div class="line">            <span class="comment">// Other calculations.</span></div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> int_consumer =</div>
<div class="line">        <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;int_consumer&quot;</span>, [deadline, int_future = std::move(int_future), kTestValue]() <span class="keyword">mutable</span> {</div>
<div class="line">            <span class="keyword">auto</span> status = int_future.wait_until(deadline);</div>
<div class="line">            <span class="keyword">auto</span> x = kBadValue;</div>
<div class="line">            <span class="keywordflow">switch</span> (status) {</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a25d5606fe07425ea73f245c48612c039" title="the future is ready">engine::FutureStatus::kReady</a>:</div>
<div class="line">                    x = int_future.get();</div>
<div class="line">                    ASSERT_EQ(x, kTestValue);</div>
<div class="line">                    <span class="comment">// ...</span></div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a7f27861ff1d3f550c6aa77150d7edabd" title="the wait operation timed out">engine::FutureStatus::kTimeout</a>:</div>
<div class="line">                    <span class="comment">// Timeout Handling</span></div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a971493a769ad0aed23946733ede4a8f1" title="the wait operation was interrupted by task cancellation">engine::FutureStatus::kCancelled</a>:</div>
<div class="line">                    <span class="comment">// Handling cancellation of calculations</span></div>
<div class="line">                    <span class="comment">// (example, return to queue)</span></div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> string_consumer =</div>
<div class="line">        <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;string_consumer&quot;</span>, [string_future = std::move(string_future), kTestString]() <span class="keyword">mutable</span> {</div>
<div class="line">            std::string s;</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                s = string_future.get();</div>
<div class="line">                ASSERT_EQ(s, kTestString);</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div>
<div class="line">                <span class="comment">// Exception Handling</span></div>
<div class="line">                s = kFallbackString;</div>
<div class="line">            }</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    calc_task.Get();</div>
<div class="line">    int_consumer.Get();</div>
<div class="line">    string_consumer.Get();</div>
</div><!-- fragment --><p>In this case, the main mechanism for transmitting data remains the return of values from TaskWithResult.</p>
<h2><a class="anchor" id="autotoc_md546"></a>
engine::WaitAny and friends</h2>
<p>The most effective way to wait for one of the asynchronous operations is to use <a class="el" href="../../dc/db7/group__userver__concurrency.html#ga6fc06edbfecd5d58598fb3880ae9edb2" title="Waits for the completion of any of the specified tasks or the cancellation of the caller.">engine::WaitAny</a>, engine::WaitAnyFor or engine::WaitAnyUntil:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> task0 = <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#ac249644dedd4351b50adc96c8b76c358" title="Runs an asynchronous function call using specified task processor.">engine::AsyncNoSpan</a>([] { <span class="keywordflow">return</span> 1; });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> task1 = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;long_task&quot;</span>, [] {</div>
<div class="line">        <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#a19462f750672c6fa7f5f690c2575b9f6">engine::InterruptibleSleepFor</a>(20s);</div>
<div class="line">        <span class="keywordflow">return</span> std::string{<span class="stringliteral">&quot;abc&quot;</span>};</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> task_idx_opt = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga6fc06edbfecd5d58598fb3880ae9edb2" title="Waits for the completion of any of the specified tasks or the cancellation of the caller.">engine::WaitAny</a>(task0, task1);</div>
<div class="line">    ASSERT_TRUE(task_idx_opt);</div>
<div class="line">    EXPECT_EQ(*task_idx_opt, 0);</div>
</div><!-- fragment --><p>It works with different types of tasks and futures. For example could be used to get the ready HTTP requests ASAP:</p>
<div class="fragment"><div class="line">std::size_t ProcessReadyRequests(std::vector&lt;clients::http::ResponseFuture&gt;&amp; requests, <a class="code hl_class" href="../../de/d6a/classengine_1_1Deadline.html" title="Internal representation of a deadline time point.">engine::Deadline</a> deadline) {</div>
<div class="line">    std::size_t processed_requests = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">auto</span> indx = engine::WaitAnyUntil(deadline, requests)) {</div>
<div class="line">        ++processed_requests;</div>
<div class="line"> </div>
<div class="line">        std::shared_ptr&lt;clients::http::Response&gt; response = requests[*indx].Get();</div>
<div class="line">        EXPECT_TRUE(response-&gt;IsOk());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> processed_requests;</div>
<div class="line">}</div>
</div><!-- fragment --><p>See also <a class="el" href="../../dc/db7/group__userver__concurrency.html#gae7a0b9edf6e9e23e3433edafc6d59279" title="Waits for the successful completion of all of the specified tasks or for the cancellation of the call...">engine::WaitAllChecked</a> and <a class="el" href="../../dc/db7/group__userver__concurrency.html#ga26c1ba3047210ae48bbc0f027fedd31c" title="Waits for the successful completion of all of the specified tasks or the cancellation of the caller.">engine::GetAll</a> for a way to wait for all of the asynchronous operations, rethrowing exceptions immediately.</p>
<h2><a class="anchor" id="autotoc_md547"></a>
concurrent::MpscQueue and friends</h2>
<p>For long-living tasks it is convenient to use message queues. In <code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a></code>, writers (one or more) can write data to the queue, and on the other hand, a reader can read what is written. The order of objects written by different writers is not defined.</p>
<div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::chrono::milliseconds kTimeout{10};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> queue = <a class="code hl_function" href="../../d0/d92/classconcurrent_1_1MpscQueue.html#a6fc6c451d62b7c1fc92e6779487ec709" title="Create a new queue.">concurrent::MpscQueue&lt;int&gt;::Create</a>();</div>
<div class="line">    <span class="keyword">auto</span> producer = queue-&gt;GetProducer();</div>
<div class="line">    <span class="keyword">auto</span> consumer = queue-&gt;GetConsumer();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> producer_task = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;producer&quot;</span>, [&amp;] {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <span class="keywordflow">if</span> (!producer.Push(1, <a class="code hl_function" href="../../de/d6a/classengine_1_1Deadline.html#af4ebdc7f5c1074c2bbc559345b8a289f" title="Converts duration to a Deadline.">engine::Deadline::FromDuration</a>(kTimeout))) {</div>
<div class="line">            <span class="comment">// The reader is dead</span></div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> consumer_task = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;consumer&quot;</span>, [&amp;] {</div>
<div class="line">        <span class="keywordflow">for</span> (;;) {</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordtype">int</span> item{};</div>
<div class="line">            <span class="keywordflow">if</span> (consumer.Pop(item, <a class="code hl_function" href="../../de/d6a/classengine_1_1Deadline.html#af4ebdc7f5c1074c2bbc559345b8a289f" title="Converts duration to a Deadline.">engine::Deadline::FromDuration</a>(kTimeout))) {</div>
<div class="line">                <span class="comment">// processing the queue element</span></div>
<div class="line">                ASSERT_EQ(item, 1);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// the queue is empty and there are no more live producers</span></div>
<div class="line">                return;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">    producer_task.Get();</div>
<div class="line">    consumer_task.Get();</div>
</div><!-- fragment --><p>(<code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a></code> only.) If the queue is supposed to pass data types <code>T</code> with a non-trivial destructor, then you need to use the queue <code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a>&lt;std::unique_ptr&lt;T&gt;&gt;</code>.</p>
<p>If the queue with unread data is destroyed, all unprocessed items will be released correctly.</p>
<p>Use <code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a></code> by default.</p>
<p>If there is only a single producing task, these can be used instead for higher performance:</p>
<ul>
<li><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#ga1f9856ce2c9662e47a69725e04aa9e5c" title="Single producer single consumer queue.">concurrent::SpscQueue</a></code></li>
<li><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#gad3ba33f3d929534956f5fda667ba32dc" title="Single producer multiple consumers queue.">concurrent::SpmcQueue</a></code></li>
</ul>
<p>If reordering of the elements is acceptable, these can be used instead for higher performance:</p>
<ul>
<li><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#ga932e4409d1cd0c740a04567c0b778efd" title="Non FIFO multiple producers single consumer queue.">concurrent::NonFifoMpscQueue</a></code></li>
<li><code><a class="el" href="../../dc/db7/group__userver__concurrency.html#ga564b6fabf9ca1dc0dfa7c5ec3f3172ef" title="Non FIFO multiple producers multiple consumers queue.">concurrent::NonFifoMpmcQueue</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md548"></a>
std::atomic</h2>
<p>If you need to access small trivial types (<code>int</code>, <code>long</code>, <code>std::size_t</code>, <code>bool</code>) in shared memory from different tasks, then atomic variables may help. Beware, for complex types compiler generates code with implicit use of synchronization primitives forbidden in userver. If you are using <code>std::atomic</code> with a non-trivial or type parameters with big size, then be sure to write a test to check that accessing this variable does not impose a mutex.</p>
<p>It is not recommended to use non-default memory_orders (for example, acquire/release), because their use is fraught with great difficulties. In such code, it is very easy to get bug that will be extremely difficult to detect. Therefore, it is better to use a simpler and more reliable default, the std::memory_order_seq_cst.</p>
<p><a class="anchor" id="userver_thread_local"></a></p>
<h2><a class="anchor" id="autotoc_md549"></a>
thread_local</h2>
<p>For "handy thread-safe global storage", use <code><a class="el" href="../../d0/d40/classengine_1_1TaskLocalVariable.html" title="TaskLocalVariable is a per-coroutine variable of arbitrary type.">engine::TaskLocalVariable</a></code> instead of <code>thread_local</code>. Better still, avoid global state and pass data between functions explicitly.</p>
<p>For passing global data within a single request, e.g. from handlers to clients using middlewares, use <code><a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html" title="TaskInheritedVariable is a per-coroutine variable of arbitrary type.">engine::TaskInheritedVariable</a></code>.</p>
<p>For fast insecure randomness (suitable e.g. for load balancing), use:</p>
<ul>
<li><code><a class="el" href="../../d6/d84/namespaceutils.html#a6ce3304039d4f172c6a8c522e2ad38ef" title="Generates a random number in range [from, to)">utils::RandRange</a></code> for generating simple uniform random numbers;</li>
<li><code><a class="el" href="../../d6/d84/namespaceutils.html#a5e593de13b808a1d01665815a0b858e7" title="Shuffles the elements within the container.">utils::Shuffle</a></code> instead of <code>std::shuffle</code>;</li>
<li><code><a class="el" href="../../d6/d84/namespaceutils.html#a0d09c01e356b65e7384fa433d3751463" title="Calls func with a thread-local UniformRandomBitGenerator (specifically of type utils::RandomBase).">utils::WithDefaultRandom</a></code> for other cases.</li>
</ul>
<p>For secure randomness (suitable e.g. for picking gifts for users), use:</p>
<ul>
<li><code><a class="el" href="../../de/d36/namespacecrypto.html#ab07cd7f76778dc58e414f17d2c820da1" title="Generate a block of randomness using a cryptographically secure RNG.">crypto::GenerateRandomBlock</a></code> for generating random binary data;</li>
<li><code><a class="el" href="../../d8/d91/classcompiler_1_1ThreadLocal.html" title="Creates a unique thread-local variable that can be used in a coroutine-safe manner.">compiler::ThreadLocal</a></code> + <code>CryptoPP::AutoSeededRandomPool</code> for other cases.</li>
</ul>
<p><code>thread_local</code>, when used with userver, suffers from issues described in <code><a class="el" href="../../d8/d91/classcompiler_1_1ThreadLocal.html" title="Creates a unique thread-local variable that can be used in a coroutine-safe manner.">compiler::ThreadLocal</a></code>. So for all other needs, use <code><a class="el" href="../../d8/d91/classcompiler_1_1ThreadLocal.html" title="Creates a unique thread-local variable that can be used in a coroutine-safe manner.">compiler::ThreadLocal</a></code> instead of <code>thread_local</code>.</p>
<h2><a class="anchor" id="autotoc_md550"></a>
engine::Mutex</h2>
<p>A classic mutex. It allows you to work with standard <code>std::unique_lock</code> and <code>std::lock_guard</code>.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">engine::Mutex</a> mutex;</div>
<div class="line">    <span class="keyword">constexpr</span> std::string_view kTestData = <span class="stringliteral">&quot;Test Data&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;engine::Mutex&gt; lock(mutex);</div>
<div class="line">        <span class="comment">// accessing data under a mutex</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> x = kTestData;</div>
<div class="line">        ASSERT_EQ(kTestData, x);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Prefer using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code> instead of an <code><a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">engine::Mutex</a></code>.</p>
<h2><a class="anchor" id="autotoc_md551"></a>
engine::SharedMutex</h2>
<p>A mutex that has readers and writers. It allows you to work with standard <code>std::unique_lock</code>,<code>std::lock_guard</code> and <code>std::shared_lock</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;123&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks.">engine::SharedMutex</a> mutex;</div>
<div class="line">    std::string data;</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;engine::SharedMutex&gt; lock(mutex);</div>
<div class="line">        <span class="comment">// accessing the data under the mutex for writing</span></div>
<div class="line">        data = kTestString;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        std::shared_lock&lt;engine::SharedMutex&gt; lock(mutex);</div>
<div class="line">        <span class="comment">// accessing the data under the mutex for reading,</span></div>
<div class="line">        <span class="comment">// data cannot be changed</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = data;</div>
<div class="line">        ASSERT_EQ(x, kTestString);</div>
<div class="line">    }</div>
</div><!-- fragment --><p><a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks.">engine::SharedMutex</a> is a much more complex and heavier synchronization primitive than a regular <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">engine::Mutex</a>. The fact of the existence of readers and writers does not mean that <a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks.">engine::SharedMutex</a> will be faster than an <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">engine::Mutex</a>. For example, if the critical section is small (2-3 integer variables), then the SharedMutex overhead can outweigh all the gain from concurrent reads. Therefore, you should not mindlessly use SharedMutex without benchmarks. Also, the "frequent reads, rare writes" scenario in most cases is solved much more efficiently through RCU - <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code>.</p>
<p>Read locking of the SharedMutex is slower than reading an <code>RCU</code>. However, SharedMutex does not require copying data on modification, unlike <code>RCU</code>. Therefore, in the case of expensive data copies that are protected by a critical section, it makes sense to use SharedMutex instead of <code>RCU</code>. If the cost of copying is low, then it is usually more profitable to use <code>RCU</code>.</p>
<p>To work with a mutex, we recommend using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code>. This reduces the risk of taking a mutex in the wrong mode, the wrong mutex, and so on.</p>
<h2><a class="anchor" id="autotoc_md552"></a>
rcu::Variable</h2>
<p>A synchronization primitive with readers and writers that allows readers to work with the old version of the data while the writer fills in the new version of the data. Multiple versions of the protected data can exist at any given time. The old version is deleted when the RCU realizes that no one else is working with it. This can happen when writing a new version is finished if there are no active readers. If at least one reader holds an old version of the data, it will not be deleted.</p>
<p>RCU should be the "default" synchronization primitive for the case of frequent readers and rare writers. Very poorly suited for frequent updates, because a copy of the data is created on update.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> kOldValue = 1;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kOldString = <span class="stringliteral">&quot;Old string&quot;</span>;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> kNewValue = 2;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kNewString = <span class="stringliteral">&quot;New string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>Data {</div>
<div class="line">        <span class="keywordtype">int</span> x;</div>
<div class="line">        std::string s;</div>
<div class="line">    };</div>
<div class="line">    <a class="code hl_class" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable&lt;Data&gt;</a> data{Data{kOldValue, kOldString}};</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> ro_ptr = data.<a class="code hl_function" href="../../d8/d5a/classrcu_1_1Variable.html#a47c26789c7190d5b088b5ee0d05b02fb" title="Obtain a smart pointer which can be used to read the current value.">Read</a>();</div>
<div class="line">        <span class="comment">// We can use ro_ptr to access data.</span></div>
<div class="line">        <span class="comment">// At this time, neither the writer nor the other readers are not blocked</span></div>
<div class="line">        <span class="comment">// =&gt; you can hold a smart pointer without fear of blocking other users</span></div>
<div class="line">        ASSERT_EQ(ro_ptr-&gt;x, kOldValue);</div>
<div class="line">        ASSERT_EQ(ro_ptr-&gt;s, kOldString);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> ptr = data.<a class="code hl_function" href="../../d8/d5a/classrcu_1_1Variable.html#a5c51871ec5be0a47cb620cb54fd210cb">StartWrite</a>();</div>
<div class="line">        <span class="comment">// ptr stores a copy of the latest version of the data, now we can prepare</span></div>
<div class="line">        <span class="comment">// a new version Readers continue to access the old version of the data</span></div>
<div class="line">        <span class="comment">// via .Read()</span></div>
<div class="line">        ptr-&gt;x = kNewValue;</div>
<div class="line">        ptr-&gt;s = kNewString;</div>
<div class="line">        <span class="comment">// After Commit(), the next reader in Read() gets the version of the data</span></div>
<div class="line">        <span class="comment">// we just wrote. Old readers who did Read() before Commit() continue to</span></div>
<div class="line">        <span class="comment">// work with the old version of the data.</span></div>
<div class="line">        ptr.Commit();</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Comparison with SharedMutex is described in the <code><a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks.">engine::SharedMutex</a></code> section of this page.</p>
<h2><a class="anchor" id="autotoc_md553"></a>
rcu::RcuMap</h2>
<p><code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> based map. This primitive is used when you need a concurrent dictionary. Well suited for the case of rarely added keys. Poorly suited to the case of a frequently changing set of keys.</p>
<p>Note that RcuMap does not protect the value of the dictionary, it only protects the dictionary itself. If the values are non-atomic types, then they must be protected separately (for example, using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code>).</p>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>Data {</div>
<div class="line">        <span class="comment">// Access to RcuMap content must be synchronized via std::atomic</span></div>
<div class="line">        <span class="comment">// or other synchronization primitives</span></div>
<div class="line">        std::atomic&lt;int&gt; x{0};</div>
<div class="line">        std::atomic&lt;bool&gt; flag{<span class="keyword">false</span>};</div>
<div class="line">    };</div>
<div class="line">    <a class="code hl_class" href="../../d0/d1f/classrcu_1_1RcuMap.html" title="Map-like structure allowing RCU keyset updates.">rcu::RcuMap&lt;std::string, Data&gt;</a> map;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If the key is not in the dictionary,</span></div>
<div class="line">    <span class="comment">// then a default object will be created</span></div>
<div class="line">    map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;x++;</div>
<div class="line">    map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;flag = <span class="keyword">true</span>;</div>
<div class="line">    ASSERT_EQ(map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;x.load(), 1);</div>
<div class="line">    ASSERT_EQ(map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;flag.load(), <span class="keyword">false</span>);</div>
<div class="line">    ASSERT_EQ(map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;x.load(), 0);</div>
<div class="line">    ASSERT_EQ(map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;flag.load(), <span class="keyword">true</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md554"></a>
concurrent::Variable</h2>
<p>A proxy class that combines user data and a synchronization primitive that protects that data. Its use can greatly reduce the number of bugs associated with incorrect use of the critical section - taking the wrong mutex, forgetting to take the mutex, taking SharedMutex in the wrong mode, etc.</p>
<div class="fragment"><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;Test string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>Data {</div>
<div class="line">        <span class="keywordtype">int</span> x = 0;</div>
<div class="line">        std::string s{};</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// If you do not specify the 2nd template parameter,</span></div>
<div class="line">    <span class="comment">// then by default Variable is protected by engine::Mutex.</span></div>
<div class="line">    <a class="code hl_class" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable&lt;Data, engine::SharedMutex&gt;</a> data;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We get a smart pointer to the data,</span></div>
<div class="line">        <span class="comment">// the smart pointer stores std::lock_guard</span></div>
<div class="line">        <span class="keyword">auto</span> data_ptr = data.Lock();</div>
<div class="line">        data_ptr-&gt;s = kTestString;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We get a smart pointer to the data,</span></div>
<div class="line">        <span class="comment">// the smart pointer stores std::shared_lock</span></div>
<div class="line">        <span class="keyword">auto</span> data_ptr = data.SharedLock();</div>
<div class="line">        <span class="comment">// we can read data, we cannot write</span></div>
<div class="line">        ASSERT_EQ(data_ptr-&gt;s, kTestString);</div>
<div class="line">    }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md555"></a>
engine::Semaphore</h2>
<p>The semaphore is used to limit the number of users that run inside a critical section. For example, a semaphore can be used to limit the number of simultaneous concurrent attempts to connect to a resource.</p>
<div class="fragment"><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> kMaxSimultaneousLocks = 3;</div>
<div class="line">    <a class="code hl_class" href="../../db/d16/classengine_1_1Semaphore.html" title="Class that allows up to max_simultaneous_locks concurrent accesses to the critical section....">engine::Semaphore</a> sema(kMaxSimultaneousLocks);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    {</div>
<div class="line">        std::shared_lock lock(sema);</div>
<div class="line">        <span class="comment">// There may be no more than 3 users</span></div>
<div class="line">        <span class="comment">// in the critical section at the same time</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p>You don't need to use a semaphore if you need to limit the number of threads that perform CPU-heavy operations. For these purposes, create a separate TaskProcessor and perform other operations on it, it is be cheaper in terms of synchronization.</p>
<p>If you need a counter, but do not need to wait for the counter to change, then you need to use <code>std::atomic</code> instead of a semaphore.</p>
<h2><a class="anchor" id="autotoc_md556"></a>
engine::SingleUseEvent</h2>
<p>A single-producer, single-consumer event without task cancellation support. Must not be awaited or signaled multiple times in the same waiting session.</p>
<p>For multiple producers and cancellation support, use <code><a class="el" href="../../d8/d87/classengine_1_1SingleConsumerEvent.html" title="A multiple-producers, single-consumer event.">engine::SingleConsumerEvent</a></code> instead.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult&lt;void&gt;</a> sender;</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="../../dc/dde/classengine_1_1SingleUseEvent.html" title="A single-producer, single-consumer event.">engine::SingleUseEvent</a> event;</div>
<div class="line">        sender = <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;sender&quot;</span>, [&amp;event] { <span class="keyword">event</span>.Send(); });</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">event</span>.WaitNonCancellable();  <span class="comment">// will be woken up by &#39;Send()&#39; above</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// &#39;event&#39; is destroyed here. Note that &#39;Send&#39; might continue executing, but</span></div>
<div class="line">        <span class="comment">// it will still complete safely.</span></div>
<div class="line">    }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md557"></a>
utils::SwappingSmart</h2>
<p><b>Don't use</b> <code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code>, use <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> instead. There is a UB in the SwappingSmart behavior.</p>
<p><code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code> protects readers from rare writers, but in the case of very frequent writers, the reader has no guarantee of getting a valid <code>std::shared_ptr</code> (which occasionally fired in production). Also <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> faster than <code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code> in most cases.</p>
<hr  />
<p> <div class="bottom-nav">  ‚á¶ <a class="el" href="../../dd/d1c/group__userver__components.html">Components</a> | <a class="el" href="../../d2/d20/md_en_2userver_2formats.html">Formats (JSON, YAML, BSON, ...)</a> ‚á®  </div>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:56:00 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
