<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Basics of Caches</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d2d/md_en_2userver_2caches.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Basics of Caches</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md101"></a> A cache in userver is a <a class="el" href="../../dc/dcc/md_en_2userver_2component__system.html">component</a> that periodically polls an external resource and caches its response. Strictly speaking, the cache component is a shadow replica of some resource (database tables, mongo collections, etc.). The use of the cache is that the user receives the current data snapshot and works with that snapshot without waiting for updates. Cache updates occur asynchronously in the background and do not block users from working with the cache.</p>
<p>As a result, the user usually works with slightly outdated data, but at the same time always has an instant access to some version of the data.</p>
<p>Caches usually inherit from <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> or <a class="el" href="../../d9/d97/classcache_1_1LruCacheComponent.html" title="Base class for LRU-cache components.">cache::LruCacheComponent</a>. Sections below describe the features of <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a>. For information on <a class="el" href="../../d9/d97/classcache_1_1LruCacheComponent.html" title="Base class for LRU-cache components.">cache::LruCacheComponent</a> refer to <a class="el" href="../../d0/dd8/md_en_2userver_2lru__cache.html">Least Recently Used (LRU) Caches and expirable LRU caches</a>.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Update Modes</h1>
<p>Caches have two update modes:</p><ul>
<li>Full update. In this mode, the cache requests its full state from an external resource.</li>
<li>Incremental update. In this mode, the cache requests changes since the last Full update, patching its current state.</li>
</ul>
<p>If there has not been a successful full update for a long time (more than the value of <code>full-update-interval</code>), then the next update will be full. In particular, if there is a full update error, the next update will also be full.</p>
<p>The cache can disable incremental updates and work only in full updates mode, or vice versa - work only in incremental updates mode. The very first update is always full, regardless of the settings.</p>
<p>Here's a sample update mode settings of <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> based cache: </p><div class="fragment"><div class="line">yaml</div>
<div class="line">  mongo-dynamic-config-cache:</div>
<div class="line">    update-interval: 5s</div>
<div class="line">    update-jitter: 1s</div>
<div class="line">    full-update-interval: 10s</div>
<div class="line">    update-types: full-and-incremental</div>
</div><!-- fragment --><p>To disable incremental/full updates, specify this in the <code>update-types</code> tag, for example: </p><div class="fragment"><div class="line">yaml</div>
<div class="line">  js-pipeline-compilation:</div>
<div class="line">    # Can be only-full, only-incremental, full-and-incremental</div>
<div class="line">    update-types: only-full</div>
<div class="line">    update-interval: 180s</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Update intervals</h2>
<p><code>update-interval</code> is the time interval between the <code>Update</code> calls. In particular this means:</p><ul>
<li><code>Update</code> is not called concurrently</li>
<li>Only with <code>update-jitter: 0s</code> and <code>is-strong-period: true</code> updates follow a strict schedule.</li>
</ul>
<p><code>full-update-interval</code> is the minimum interval between <code>full</code> updates in <code>full-and-incremental</code> cache. With each update, the cache checks if <code>full-update-interval</code> of the time has passed since the previous <code>full</code> update, and if it has passed, the current update will be <code>full</code>.</p>
<p><code>update-jitter</code> describes the spread in the delay between cache updates. It is especially useful in the case of heavy caches, which significantly load the database/remote with their updates. Adding a random delay spreads the cache updates of various instances over time, thereby removing the peak load on the database/remote.</p>
<h1><a class="anchor" id="autotoc_md104"></a>
Fault Tolerance</h1>
<p>The user can get the current cache snapshot regardless of the current state of the database/remote from which the cache is being poured, provided that at least once the cache update worked correctly. The user is working with a local copy, which may be slightly behind the original in time. In case of problems with the database/remote the cache update may finish with an error (i.e. the <code>Update</code> method will throw an exception), leaving the local cache unchanged.</p>
<p>By default, the first cache update must be completed successfully to set the initial value. If the first update fails with an error, i.e. the update throws an exception, then this leads to an exception in the cache component constructor and to the service shutdown. There are two ways to change this behavior:</p><ol type="1">
<li><a class="el" href="../../da/dd6/md_en_2userver_2cache__dumps.html">By enabling dumps</a>, in this case the cache starts with the state stored in the dump. If there is no dump, the service will still fall when the first update fails. You can overcome this through next clause</li>
<li>By giving a permission to load without the first update. In case of auxiliary cache, it may be useful to leave the cache in an error state and asynchronously update it after the service start. To do this, specify <code>first-update-fail-ok</code> in the component settings: <div class="fragment"><div class="line">yaml</div>
<div class="line">  first-update-fail-ok-cache:</div>
<div class="line">  update-interval: 60s</div>
<div class="line">  update-jitter: 10s</div>
<div class="line">  full-update-interval: 1000s</div>
<div class="line">  first-update-fail-ok: true</div>
</div><!-- fragment --></li>
</ol>
<p>If the "cache has no data" situation is normal for you and you want to handle it yourself, you can override the <code>MayReturnNull()</code> method in the cache so that it returns <code>true</code> (by default <code>false</code>). In this case, instead of an exception, you will get an empty smart pointer (<code>nullptr</code>).</p>
<h1><a class="anchor" id="autotoc_md105"></a>
Access synchronization, versioning, memory consumption</h1>
<p>Cache implementation does not block multiple concurrent cache readers while doing a background cache update. In case of time consuming work with cache data, users may encounter the fact that different readers work with different versions of the data. As a result, more than two versions of the cache data can coexist at the same time. Memory and other resources of old data versions are released either when updating the cache or when the background garbage collector collects the garbage. The frequency of garbage collection is regulated via the <code>additional-cleanup-interval</code> parameter.</p>
<p>The total amount of memory for the cache can be approximately calculated by the formula: </p><div class="fragment"><div class="line">Total cache memory = cache data memory * ([user time / update interval] + 1)</div>
</div><!-- fragment --><p> where:</p><ul>
<li><code>cache data memory</code> is the maximum size of one cache copy</li>
<li><code>update interval</code> - minimum cache update period</li>
<li><code>user time</code> - the maximum time that users hold a copy of the cache (i.e. the lifetime of the <code>Get()</code> result)</li>
</ul>
<p>For example, if the cache data occupies 1 GB, the cache is updated every 4 seconds, and the handle works for 9 seconds, then the total memory consumption of the cache is <code>1 GB * ([9/4]+1) = 4 GB</code>.</p>
<p>A commonly used technique to solve the problem of excessive memory consumption for large caches is splitting the cache into chunks.</p>
<h1><a class="anchor" id="autotoc_md106"></a>
Heavy Caches</h1>
<p>Updating caches can significantly load the CPU, for example, when parsing data from a database. If such a load lasts for a significant time without context switches (several tens of milliseconds), then this may negatively affect the timings of the service. Sometimes a similar problem occurs not only when forming a new cache snapshot, but also in the callback of a cache subscription, for example, when forming an additional cache index. There are several ways to solve this problem.</p>
<p><b>The first option</b>. Increase the number of CPU cores. The more cores you have in the service, the less CPU fraction is used by caches and the better is the efficiency of the service. On the contrary, when splitting a cluster into small containers with a small number of cores, the number of cache instances in the cluster increases, which is why the consumed by caches CPU fraction increases.</p>
<p><b>The second option</b>. Add context switching. If you call <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield()</a> every 1-2ms, then the framework engine has time to execute the other ready for execution coroutines and the queue of ready coroutines does not grow to undesirable values. To simplify working with <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield</a>, it is recommended to use <a class="el" href="../../d9/df3/classutils_1_1CpuRelax.html">utils::CpuRelax</a> rather than calling <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield()</a> manually.</p>
<h1><a class="anchor" id="autotoc_md107"></a>
Specializations for DB</h1>
<p>Caches over DB are caching components that use a trait structure as a template argument for customization. Such components are:</p>
<ul>
<li><a class="el" href="../../d2/d39/classcomponents_1_1MongoCache.html" title="Base class for all caches polling mongo collection">components::MongoCache</a></li>
<li><a class="el" href="../../d2/d8d/classcomponents_1_1PostgreCache.html" title="Caching component for PostgreSQL. See Caching Component for PostgreSQL.">components::PostgreCache</a></li>
</ul>
<p>A typical case of cache usage consists of trait structure definition:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostgresTrivialPolicy {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::string_view kName = <span class="stringliteral">&quot;my-pg-cache&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>ValueType = MyStructure;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kKeyMember = &amp;MyStructure::id;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kQuery = <span class="stringliteral">&quot;SELECT a, b, updated FROM test.data&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* kUpdatedField = <span class="stringliteral">&quot;updated&quot;</span>;</div>
<div class="line">    <span class="keyword">using </span>UpdatedFieldType = <a class="code hl_struct" href="../../d7/dde/structstorages_1_1postgres_1_1TimePointTz.html" title="Corresponds to TIMESTAMP WITH TIME ZONE database type.">storages::postgres::TimePointTz</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>and registration of the caching component in <a class="el" href="../../dc/df0/classcomponents_1_1ComponentList.html" title="A list to keep a unique list of components to start with components::Run(), utils::DaemonMain() or co...">components::ComponentList</a>:</p>
<div class="fragment"></div><!-- fragment --><p>The DB caches are simple to use and quite poverfull.</p>
<h1><a class="anchor" id="autotoc_md108"></a>
Writing a cache</h1>
<p>To write your own cache using only the <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> base class, you need to override the <a class="el" href="../../da/df8/classcache_1_1CacheUpdateTrait.html#a317ae9796c9108002c4efd1227882cf5" title="Should be overridden in a derived class to align the stored data with some data source.">cache::CacheUpdateTrait::Update</a>, implement Full and Incremental updates. In Update(), don't forget to put down metrics for the <code>stats_scope</code> object, describing how many objects were read, how many parsing errors there were, and how many elements are in the final cache.</p>
<p>See <a class="el" href="../../dc/d8a/md_en_2userver_2tutorial_2http__caching.html">Pre-caching data from HTTP remote</a> for a detailed introduction.</p>
<h1><a class="anchor" id="autotoc_md109"></a>
Parallel loading</h1>
<p>Cache components, like other components, are loaded in parallel. This allows you to speed up the loading of the service in the case of multiple heavy caches.</p>
<h1><a class="anchor" id="autotoc_md110"></a>
Metrics</h1>
<p>Each cache automatically collects metrics. See <a class="el" href="../../d9/dac/md_en_2userver_2service__monitor.html">Service Statistics and Metrics (Prometheus/Graphite/...)</a> for a list of metrics with some descriptions.</p>
<h1><a class="anchor" id="autotoc_md111"></a>
Common misuses</h1>
<ul>
<li>Non-const (mutable) data in cache without synchronization: <div class="fragment"><div class="line">struct CacheData {</div>
<div class="line">  int integer;                        // fine</div>
<div class="line">  std::shared_ptr&lt;std::string&gt; name;  // bad, `const CacheData` allows mutating content of `*name`</div>
<div class="line">};</div>
</div><!-- fragment --> Users of the cache could harm themselves by concurrently mutating thread-unsafe types. A fixed varsion of the above structure would be: <div class="fragment"><div class="line">struct CacheData {</div>
<div class="line">  int integer;</div>
<div class="line">  std::shared_ptr&lt;const std::string&gt; name;  // now const!</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Storing a large number of independent std::unordered_maps in the cache at once. If you need to get 3 different groups of data from 3 different sources, make 3 independent caches. This allows them to update independently, use standard cache metrics, etc.</li>
</ul>
<hr  />
<p> <div class="bottom-nav">  ⇦ <a class="el" href="../../d0/d44/md_en_2userver_2congestion__control.html">Congestion Control</a> | <a class="el" href="../../da/dd6/md_en_2userver_2cache__dumps.html">Local cache dumps</a> ⇨  </div>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:55:58 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
