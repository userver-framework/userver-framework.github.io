<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Dynamic config</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d46/md_en_2userver_2dynamic__config.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dynamic config</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md215"></a> For schemas of dynamic configs used by userver itself: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html">Dynamic config schemas</a></dd></dl>
<p>For information on how to write a service that distributes dynamic configs: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d95/md_en_2userver_2tutorial_2config__service.html">Writing your own configs server</a></dd></dl>
<p>Dynamic config is a system of options that can be changed at runtime without restarting the service.</p>
<p>Dynamic config is distributed as a large JSON object where each direct member is called a dynamic config variable, or (somewhat confusingly) a dynamic config. For example:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="stringliteral">&quot;POSTGRES_DEFAULT_COMMAND_CONTROL&quot;</span>: {</div>
<div class="line">    <span class="stringliteral">&quot;network_timeout_ms&quot;</span>: 750,</div>
<div class="line">    <span class="stringliteral">&quot;statement_timeout_ms&quot;</span>: 500</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;USERVER_DEADLINE_PROPAGATION_ENABLED&quot;</span>: <span class="keyword">true</span>,</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md216"></a>
Why your service needs dynamic configs</h2>
<p>Dynamic configs are an essential part of a reliable service with high availability. The configs could be used as an emergency switch for new functionality, selector for experiments, limits/timeouts/log-level setup, proxy setup and so forth.</p>
<p>See <a class="el" href="../../db/d69/md_en_2userver_2tutorial_2production__service.html">Production configs and best practices</a> setup example.</p>
<h2><a class="anchor" id="autotoc_md217"></a>
Adding and using your own dynamic configs</h2>
<p>Dynamic config values are obtained via the <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html" title="A client for easy dynamic config fetching in components.">dynamic_config::Source</a> client that is retrieved from <a class="el" href="../../dd/d1a/classcomponents_1_1DynamicConfig.html" title="Component that stores the dynamic config.">components::DynamicConfig</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d8/d2e/core_2include_2userver_2components_2component_8hpp.html" title="Convenience header that provides all the types for component implementation (components::ComponentCon...">userver/components/component.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d2/d88/core_2include_2userver_2dynamic__config_2storage_2component_8hpp.html" title="Component that stores the dynamic config.">userver/dynamic_config/storage/component.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;userver/dynamic_config/value.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../de/d4e/utils_2async_8hpp.html" title="Utility functions to start asynchronous tasks.">userver/utils/async.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../dc/d5f/merge__schemas_8hpp.html" title="Merge parent and child components schemas of static configs.">userver/yaml_config/merge_schemas.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>myservice::smth {</div>
<div class="line"> </div>
<div class="line">Component::Component(<span class="keyword">const</span> <a class="code hl_class" href="../../db/dff/classcomponents_1_1ComponentConfig.html">components::ComponentConfig</a>&amp; config, <span class="keyword">const</span> <a class="code hl_class" href="../../da/db1/classcomponents_1_1ComponentContext.html" title="Class to retrieve other components.">components::ComponentContext</a>&amp; context)</div>
<div class="line">    : <a class="code hl_namespace" href="../../d0/d1f/namespacecomponents.html" title="Contains functions and types to start a userver based service/tool.">components</a>::ComponentBase(config, context),</div>
<div class="line">      config_(</div>
<div class="line">          <span class="comment">// Searching for some component to initialize members</span></div>
<div class="line">          context.FindComponent&lt;<a class="code hl_namespace" href="../../d0/d1f/namespacecomponents.html" title="Contains functions and types to start a userver based service/tool.">components</a>::DynamicConfig&gt;().GetSource()  <span class="comment">// getting &quot;client&quot; from a component</span></div>
<div class="line">      ) {</div>
<div class="line">    <span class="comment">// Reading config values from static config</span></div>
<div class="line">    [[maybe_unused]] <span class="keyword">auto</span> url = config[<span class="stringliteral">&quot;some-url&quot;</span>].<a class="code hl_function" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html#a64c0d693118c8a737838bd9acb671069" title="Returns value of *this converted to T.">As</a>&lt;std::string&gt;();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> fs_tp_name = config[<span class="stringliteral">&quot;fs-task-processor&quot;</span>].<a class="code hl_function" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html#a64c0d693118c8a737838bd9acb671069" title="Returns value of *this converted to T.">As</a>&lt;std::string&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Starting a task on a separate task processor from config</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; fs_task_processor = context.<a class="code hl_function" href="../../da/db1/classcomponents_1_1ComponentContext.html#a0f8bdf097d092609d4efb31aeb9fbdc7" title="Returns an engine::TaskProcessor with the specified name.">GetTaskProcessor</a>(fs_tp_name);</div>
<div class="line">    <a class="code hl_function" href="../../dc/db7/group__userver__concurrency.html#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(fs_task_processor, <span class="stringliteral">&quot;my-component/fs-work&quot;</span>, [] { <span class="comment">/*...*/</span> }).Get();</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace myservice::smth</span></div>
</div><!-- fragment --><p>To read the config, you first need to define a global <a class="el" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key</a> variable for it. Second, you should get the current value from the config using the <code>Key</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>myservice::smth {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <a class="code hl_class" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key</a> kMyConfig{<span class="stringliteral">&quot;SAMPLE_INTEGER_FROM_RUNTIME_CONFIG&quot;</span>, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> Component::DoSomething()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">// Getting a snapshot of dynamic config.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> runtime_config = config_.GetSnapshot();</div>
<div class="line">    <span class="keywordflow">return</span> runtime_config[kMyConfig];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace myservice::smth</span></div>
</div><!-- fragment --><p>You can also subscribe to dynamic config updates using <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html#ad7ed3eb0541b0252e20b7719a3dcb3bc">dynamic_config::Source::UpdateAndListen</a> functions, see their docs for details.</p>
<p><a class="anchor" id="dynamic_config_key"></a></p>
<h3><a class="anchor" id="autotoc_md218"></a>
What is needed to define a dynamic config</h3>
<p>A <a class="el" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key</a> requires 3 main elements:</p>
<ol type="1">
<li>The config name.<ul>
<li>We use UPPER_CASE for config names.</li>
</ul>
</li>
<li>The way to parse the JSON value into a C++ object.<ul>
<li>The default way that should be used in most scenarios is the normal JSON formats parsing. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#dynamic_config_parsing">dynamic_config_parsing</a></dd></dl>
</li>
<li>For edge case scenarios, <a class="el" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key</a> constructors provide various other ways to parse configs, refer to its documentation for details.</li>
</ul>
</li>
<li>The default config value.<ul>
<li>If the whole config type is a <a class="el" href="#dynamic_config_parsing_trivial">trivial type</a> , then the default value may be provided directly as a C++ literal.</li>
<li>For more complex types (e.g. objects), <a class="el" href="../../d6/dc5/structdynamic__config_1_1DefaultAsJsonString.html" title="A strong typedef for usage in dynamic_config::Key constructors.">dynamic_config::DefaultAsJsonString</a> should be used.</li>
<li><dl class="section see"><dt>See also</dt><dd><a class="el" href="#dynamic_config_defaults">how defaults are used</a>.</dd></dl>
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md219"></a>
Summary of main dynamic config classes</h2>
<h3><a class="anchor" id="autotoc_md220"></a>
dynamic_config::Snapshot</h3>
<p>A type-safe map that stores a snapshot of all used configs. <a class="el" href="../../de/d96/classdynamic__config_1_1Snapshot.html" title="The shared snapshot of dynamic configs. Cheap to copy, even cheaper to move. Thread safe,...">dynamic_config::Snapshot</a> is cheaply copyable (and even more cheaply movable), has the semantics of <code>std::shared_ptr&lt;const Impl&gt;</code>. An obtained <a class="el" href="../../de/d96/classdynamic__config_1_1Snapshot.html" title="The shared snapshot of dynamic configs. Cheap to copy, even cheaper to move. Thread safe,...">dynamic_config::Snapshot</a> instance should be stored while its configs are used or referred to.</p>
<h3><a class="anchor" id="autotoc_md221"></a>
dynamic_config::Source</h3>
<p>A reference to the configs storage, required for obtaining the actual config value and subscription to new values.</p>
<h3><a class="anchor" id="autotoc_md222"></a>
components::DynamicConfig</h3>
<p>The component that stores configs in production and <a class="el" href="#dynamic_config_testsuite">testsuite tests</a>.</p>
<p>For unit tests, <a class="el" href="../../d6/dec/classdynamic__config_1_1StorageMock.html" title="Backing storage for dynamic_config::Source in tests and benchmarks.">dynamic_config::StorageMock</a> is used instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#dynamic_config_unit_tests">dynamic_config_unit_tests</a></dd></dl>
<h2><a class="anchor" id="autotoc_md223"></a>
Recommendations on working with dynamic config</h2>
<ol type="1">
<li>Don't store and pass around <code><a class="el" href="../../dd/d1a/classcomponents_1_1DynamicConfig.html" title="Component that stores the dynamic config.">components::DynamicConfig</a>&amp;</code>. Most code should immediately call <code>GetSource()</code> on it, then use or store the <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html" title="A client for easy dynamic config fetching in components.">dynamic_config::Source</a> in a field.</li>
<li>Don't use <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html#ad7ed3eb0541b0252e20b7719a3dcb3bc">dynamic_config::Source::UpdateAndListen</a> to take a piece of config in <code>OnConfigUpdate</code> and store it into a "comfy" class field. It creates a synchronization problem out of the blue, while it has already been solved in the dynamic config API. Just store <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html" title="A client for easy dynamic config fetching in components.">dynamic_config::Source</a> in a field and call dynamic_config::Source::GetSnapshot where you need to read the config.</li>
<li>When using <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html#ad7ed3eb0541b0252e20b7719a3dcb3bc">dynamic_config::Source::UpdateAndListen</a>, be careful with the lifetime of the subscription handle (<a class="el" href="../../dd/de6/classconcurrent_1_1AsyncEventSubscriberScope.html" title="Manages the subscription to events from an AsyncEventSource.">concurrent::AsyncEventSubscriberScope</a>):<ul>
<li>Put the subscription in the class, which method is specified as the callback, as the last field, or at least below all the fields that the callback needs to work. On class destruction, first the subscription object will be destroyed, guaranteeing that <code>OnConfigUpdate</code> will not be called afterward; then other fields of the class will be destroyed.</li>
<li>If the class has a non-default destructor (or might have in the future), call <a class="el" href="../../dd/de6/classconcurrent_1_1AsyncEventSubscriberScope.html#aaea9d22c021e9d00525d70ac5efa6109">concurrent::AsyncEventSubscriberScope::Unsubscribe</a> somewhere in the beginning of the destructor to ensure that <code>OnConfigUpdate</code> will not be called at the point when it is already unable to run safely.</li>
</ul>
</li>
</ol>
<p><a class="anchor" id="dynamic_config_parsing"></a> </p>
<h2><a class="anchor" id="autotoc_md224"></a>
Parsing dynamic configs</h2>
<p>The following can be applied to parsing <a class="el" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> in any context, but it frequently comes up in the context of defining configs.</p>
<p>If your dynamic config is any more complex than a <a class="el" href="#dynamic_config_parsing_trivial">trivial type</a>, then you need to ensure that JSON parsing is defined for it. You may use <a class="el" href="../../d8/d43/md_en_2userver_2chaotic.html">JSON schema codegen - the Chaotic</a> if you hesitate writing the parser by yourself.</p>
<p><a class="anchor" id="dynamic_config_parsing_trivial"></a></p>
<h3><a class="anchor" id="autotoc_md225"></a>
Trivial types</h3>
<p>JSON leafs can be parsed out of the box:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">OpenAPI   </th><th class="markdownTableHeadNone">C++ type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>boolean</code>   </td><td class="markdownTableBodyNone"><code>bool</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>integer</code>   </td><td class="markdownTableBodyNone">integer types, e.g. <code>uint32_t</code>, <code>size_t</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>numeric</code>   </td><td class="markdownTableBodyNone"><code>double</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>string</code>   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td></tr>
</table>
<p>If the whole config variable is of such type, then the default value for it can be passed to <a class="el" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key</a> directly (without using <a class="el" href="../../d6/dc5/structdynamic__config_1_1DefaultAsJsonString.html" title="A strong typedef for usage in dynamic_config::Key constructors.">dynamic_config::DefaultAsJsonString</a>).</p>
<h3><a class="anchor" id="autotoc_md226"></a>
Durations</h3>
<p>Chrono durations are stored in JSON as integers:</p>
<ul>
<li><code>json.As&lt;std::chrono::seconds&gt;()</code> will parse <code>10</code> as 10 seconds;</li>
<li><code>json.As&lt;std::chrono::milliseconds&gt;()</code> will parse <code>10</code> as 10 milliseconds;</li>
<li>same for <code>minutes</code> and <code>hours</code>.</li>
</ul>
<p>To allow humans to more easily differentiate between them while looking at the JSON, we recommend ending the config name or the object label with one of the following suffixes: <code>_MS</code>, <code>_SECONDS</code>, <code>_MINUTES</code>, <code>_HOURS</code> (in the appropriate capitalization).</p>
<h3><a class="anchor" id="autotoc_md227"></a>
Enums</h3>
<p>A string that may only be selected a finite range of values should be mapped to C++ <code>enum class</code>. Parsers for enums currently have to be defined manually. Example enum parser:</p>
<div class="fragment"><div class="line">OverloadAction Parse(<span class="keyword">const</span> <a class="code hl_class" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a>&amp; value, <a class="code hl_struct" href="../../d6/dd1/structformats_1_1parse_1_1To.html">formats::parse::To&lt;OverloadAction&gt;</a>) {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <a class="code hl_class" href="../../d9/dbf/classutils_1_1TrivialBiMap.html" title="Bidirectional unordered map for trivial types, including string literals; could be efficiently used a...">utils::TrivialBiMap</a> kMap([](<span class="keyword">auto</span> selector) {</div>
<div class="line">        <span class="keywordflow">return</span> selector().Case(OverloadAction::kCancel, <span class="stringliteral">&quot;cancel&quot;</span>).Case(OverloadAction::kIgnore, <span class="stringliteral">&quot;ignore&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="../../d6/d84/namespaceutils.html#abfdfcd345adc655074de487350012146" title="Parses and returns whatever is specified by map from a formats::*::Value.">utils::ParseFromValueString</a>(value, kMap);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md228"></a>
Structs</h3>
<p>Objects are represented as C++ structs. Parsers for structs currently have to be defined manually. Example struct config:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>SampleStructConfig final {</div>
<div class="line">    <span class="keywordtype">bool</span> is_foo_enabled;</div>
<div class="line">    std::chrono::milliseconds bar_period;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <a class="code hl_class" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key&lt;SampleStructConfig&gt;</a> kSampleStructConfig;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Parser for a type must be defined in the same namespace as the type itself.</span></div>
<div class="line"><span class="comment">// In this example, JSON parser is only needed for dynamic config, so declaring</span></div>
<div class="line"><span class="comment">// it in hpp is not strictly necessary.</span></div>
<div class="line">SampleStructConfig Parse(<span class="keyword">const</span> <a class="code hl_class" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a>&amp; value, <a class="code hl_struct" href="../../d6/dd1/structformats_1_1parse_1_1To.html">formats::parse::To&lt;SampleStructConfig&gt;</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> SampleStructConfig{</div>
<div class="line">        <span class="comment">/*is_foo_enabled=*/</span>value[<span class="stringliteral">&quot;is_foo_enabled&quot;</span>].<a class="code hl_function" href="../../de/d91/classformats_1_1json_1_1Value.html#ae558cf3db117ae611a1d9f5289e85002" title="Returns value of *this converted to the result type of Parse(const Value&amp;, parse::To&lt;T&gt;)....">As</a>&lt;<span class="keywordtype">bool</span>&gt;(),</div>
<div class="line">        <span class="comment">/*bar_period=*/</span>value[<span class="stringliteral">&quot;bar_period_ms&quot;</span>].As&lt;std::chrono::milliseconds&gt;(),</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="../../d3/dc3/classdynamic__config_1_1Key.html" title="A config key is a unique identifier for a config variable.">dynamic_config::Key&lt;SampleStructConfig&gt;</a> kSampleStructConfig{</div>
<div class="line">    <span class="stringliteral">&quot;SAMPLE_STRUCT_CONFIG&quot;</span>,</div>
<div class="line">    <a class="code hl_struct" href="../../d6/dc5/structdynamic__config_1_1DefaultAsJsonString.html" title="A strong typedef for usage in dynamic_config::Key constructors.">dynamic_config::DefaultAsJsonString</a>{R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">  {</span></div>
<div class="line"><span class="stringliteral">    &quot;is_foo_enabled&quot;: false,</span></div>
<div class="line"><span class="stringliteral">    &quot;bar_period_ms&quot;: 42000</span></div>
<div class="line"><span class="stringliteral">  }</span></div>
<div class="line"><span class="stringliteral">)&quot;}};</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md229"></a>
Optionals</h3>
<p>To represent optional (non-required) properties, use <code>std::optional</code> or <code>As</code> with default. For example:</p>
<ul>
<li><code>json.As&lt;std::optional&lt;int&gt;&gt;()</code> will parse a missing value as an empty optional;</li>
<li><code>json.As&lt;int&gt;(42)</code> will parse a missing value as <code>42</code>;</li>
<li><code>json.As&lt;std::vector&lt;int&gt;&gt;({})</code> will parse a missing value as a default-constructed <code>vector</code>;</li>
<li>to assign field from config if it exists, otherwise leave the default field value: <code>field = json.As&lt;T&gt;(field)</code>.</li>
</ul>
<p>To enable support for <code>std::optional</code>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../de/d10/universal_2include_2userver_2formats_2parse_2common__containers_8hpp.html" title="Parsers and converters for Standard Library containers and std::optional.">userver/formats/parse/common_containers.hpp</a>&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md230"></a>
Containers</h3>
<p>To represent JSON arrays, use containers, typically:</p>
<ul>
<li><code>std::vector&lt;T&gt;</code></li>
<li><code>std::unordered_set&lt;T&gt;</code></li>
<li><code>std::set&lt;T&gt;</code></li>
</ul>
<p>To represent JSON objects with unknown keys (OpenAPI's <code>additionalProperties</code>), use map containers, typically:</p>
<ul>
<li><code>std::unordered_map&lt;std::string, T&gt;</code></li>
<li><code>std::map&lt;std::string, T&gt;</code></li>
</ul>
<p>To enable support for such containers, use the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../de/d10/universal_2include_2userver_2formats_2parse_2common__containers_8hpp.html" title="Parsers and converters for Standard Library containers and std::optional.">userver/formats/parse/common_containers.hpp</a>&gt;</span></div>
</div><!-- fragment --><p>If the nested type is your custom type, make sure to define <code>Parse</code> for it:</p>
<div class="fragment"><div class="line"><span class="comment">// To parse this type</span></div>
<div class="line">std::unordered_map&lt;std::string, std::optional&lt;MyStruct&gt;&gt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You need to define this parser</span></div>
<div class="line">MyStruct Parse(<span class="keyword">const</span> <a class="code hl_class" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a>&amp; value,</div>
<div class="line">               <a class="code hl_struct" href="../../d6/dd1/structformats_1_1parse_1_1To.html">formats::parse::To&lt;MyStruct&gt;</a>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md231"></a>
Recommendations on parsing dynamic configs</h3>
<ol type="1">
<li>Do not repeat the work of defining parsers for containers themselves. Define the parser for the inner type instead.</li>
<li>Do not hesitate to throw an exception if the provided config is invalid. There are <a class="el" href="#dynamic_config_fallback">multiple tiers of fallback mechanisms</a> in place to make sure it will not break the whole service. Exceptions are the preferred mechanism to signal this failure to the dynamic config system.</li>
<li>Make sure to check feasible invariants while parsing, e.g. minimum and maximum values of numbers. For that you occasionally may need to use dynamic_config::Key::Key(std::string_view name, JsonParser parser, DefaultAsJsonString default_json) Don't leave strings that are semantically enums as strings, parse them to C++ <code>enum class</code>.</li>
<li>There is typically no need to be cautious about malicious input coming from the configs service. Still, in case of a human error, it's far better to fail a config update than to crash the service or to start silently ignoring the config.</li>
</ol>
<p><a class="anchor" id="dynamic_config_defaults"></a></p>
<h2><a class="anchor" id="autotoc_md232"></a>
Dynamic config defaults</h2>
<p>Config defaults are specified in their <a class="el" href="#dynamic_config_key">C++ definition</a>. They may be overridden in the static config of <code>dynamic-config</code> component:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#dynamic_config_defaults_override">dynamic_config_defaults_override</a></dd></dl>
<p>If <a class="el" href="../../d6/d84/namespaceutils.html#a5047c1275f53e699e26869c045ad3697">utils::DaemonMain</a> is used, then the default dynamic configs can be printed by passing <code>--print-dynamic-config-defaults</code> command line option. It does not account for overrides in <code>dynamic-config</code> (<a class="el" href="../../dd/d1a/classcomponents_1_1DynamicConfig.html" title="Component that stores the dynamic config.">components::DynamicConfig</a>).</p>
<p>Dynamic config defaults are used in the following places:</p>
<ol type="1">
<li>In <a class="el" href="#dynamic_config_unit_tests">unit tests and benchmarks</a></li>
<li>In <a class="el" href="#dynamic_config_testsuite">testsuite tests</a>, defaults are the main source of configs (they can be overridden specifically for testsuite).</li>
<li>Unconditionally if config updates are not set up (<code>dynamic-config.updates-enabled: false</code>)</li>
<li>If <code>dynamic-config-client-updater</code> (<a class="el" href="../../d3/da0/classcomponents_1_1DynamicConfigClientUpdater.html" title="Component that does a periodic update of runtime configs.">components::DynamicConfigClientUpdater</a>) (or a custom updater component) receives response from the configs service with some configs missing, then <code>dynamic-config</code> (<a class="el" href="../../dd/d1a/classcomponents_1_1DynamicConfig.html" title="Component that stores the dynamic config.">components::DynamicConfig</a>) fills in those configs from defaults.</li>
<li>If <code>dynamic-config</code> component loads the config cache file, and some configs are missing, then those are filled in from defaults.</li>
</ol>
<p><a class="anchor" id="dynamic_config_setup"></a></p>
<h2><a class="anchor" id="autotoc_md233"></a>
Setting up dynamic config</h2>
<p><code>dynamic-config</code> (<a class="el" href="../../dd/d1a/classcomponents_1_1DynamicConfig.html" title="Component that stores the dynamic config.">components::DynamicConfig</a>) itself is required for the functioning of various core userver components, so it is included in both <a class="el" href="../../dd/d1c/group__userver__components.html#gae24db3a604b813e3f36497b0a1c7d792" title="Returns a list of components to do basic logging, component initialization and configuration.">components::MinimalComponentList</a> and <a class="el" href="../../dd/d1c/group__userver__components.html#ga447b5378f8d2a465ce2d6b25da09b44c" title="Returns the most common list of components with runtime config updates and HTTP client.">components::CommonComponentList</a>.</p>
<p>By default, it is configured to function in the "static dynamic config" mode and may be omitted from the static config entirely.</p>
<p><a class="anchor" id="dynamic_config_defaults_override"></a></p>
<h3><a class="anchor" id="autotoc_md234"></a>
Overriding dynamic configs defaults</h3>
<p>If you rely on obtaining ground truth configs from a configs service (as it is advised for best experience; described below), then you may skip this section entirely and use defaults only for testing.</p>
<p>On the other hand, if you prefer to run without a configs service, then you may want to override some of the <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html">built-in userver configs</a>.</p>
<p>Defaults can be overridden in the config of the <code>dynamic-config</code> component:</p>
<div class="fragment"><div class="line">        # yaml</div>
<div class="line">        dynamic-config:</div>
<div class="line">            defaults:</div>
<div class="line">                POSTGRES_CONNECTION_SETTINGS:</div>
<div class="line">                    key-value-database:</div>
<div class="line">                        max-ttl-sec: 60</div>
<div class="line">                        recent-errors-threshold: 100000</div>
<div class="line">                POSTGRES_DEFAULT_COMMAND_CONTROL:</div>
<div class="line">                    network_timeout_ms: 750</div>
<div class="line">                    statement_timeout_ms: 500</div>
<div class="line">                POSTGRES_QUERIES_COMMAND_CONTROL:</div>
<div class="line">                    sample_select_value:</div>
<div class="line">                        network_timeout_ms: 70</div>
<div class="line">                        statement_timeout_ms: 40</div>
<div class="line">                    sample_transaction_insert_key_value:</div>
<div class="line">                        network_timeout_ms: 200</div>
<div class="line">                        statement_timeout_ms: 150</div>
</div><!-- fragment --><p>In this case YAML is automatically converted to JSON, then parsed as usual.</p>
<p>Alternatively, you can pass the path to a JSON file with defaults:</p>
<div class="fragment"><div class="line"># yaml</div>
<div class="line">    dynamic-config:</div>
<div class="line">        defaults-path: $dynamic-config-defaults</div>
</div><!-- fragment --><p>It somewhat complicates the deployment process, though.</p>
<p><a class="anchor" id="dynamic_config_updates"></a></p>
<h3><a class="anchor" id="autotoc_md235"></a>
Setting up dynamic config updates</h3>
<p>Suppose that we've managed to persuade you to wind up a configs service and start actively using dynamic configs.</p>
<p>You will need the following components to download configs:</p>
<ul>
<li><a class="el" href="../../d3/da0/classcomponents_1_1DynamicConfigClientUpdater.html" title="Component that does a periodic update of runtime configs.">components::DynamicConfigClientUpdater</a></li>
<li><a class="el" href="../../d8/d1f/classcomponents_1_1DynamicConfigClient.html" title="Component that starts a clients::dynamic_config::Client client.">components::DynamicConfigClient</a> (used by the previous one)</li>
</ul>
<p>Both are included in <a class="el" href="../../dd/d1c/group__userver__components.html#ga447b5378f8d2a465ce2d6b25da09b44c" title="Returns the most common list of components with runtime config updates and HTTP client.">components::CommonComponentList</a>.</p>
<p>Here is a reasonable static config for those:</p>
<div class="fragment"><div class="line">        # yaml</div>
<div class="line">        dynamic-config:</div>
<div class="line">            updates-enabled: true</div>
<div class="line">            fs-cache-path: $config-cache</div>
<div class="line">            fs-task-processor: fs-task-processor</div>
<div class="line">        dynamic-config-client:</div>
<div class="line">            config-url: $config-server-url</div>
<div class="line">            http-retries: 5</div>
<div class="line">            http-timeout: 20s</div>
<div class="line">            service-name: $service-name</div>
<div class="line">        dynamic-config-client-updater:</div>
<div class="line">            config-settings: false</div>
<div class="line">            first-update-fail-ok: true</div>
<div class="line">            full-update-interval: 1m</div>
<div class="line">            update-interval: 5s</div>
</div><!-- fragment --><p><a class="anchor" id="dynamic_config_fallback"></a></p>
<h2><a class="anchor" id="autotoc_md236"></a>
Fallback mechanisms for dynamic configs updates</h2>
<p>Suppose that the new revision of the current service released before the newly added config was accounted by the config service. In this case it should just return the configs it knows about. The current service will fill in the blanks from the defaults.</p>
<p>If the config service gives out invalid configs (which fail to be parsed), then the periodic config update will fail, and alerts will fire:</p>
<ol type="1">
<li><code>dynamic-config.parse-errors</code> metric (1) will be incremented, and <code>dynamic-config.was-last-parse-successful</code> metric (2) will be set to 1. You can combine those to safely detect parsing errors in the metrics backend: <div class="fragment"><div class="line">if ((1) != previous (1) || (2) == 0) show alert</div>
</div><!-- fragment --></li>
<li>An alert will be registered in <a class="el" href="../../da/d84/classalerts_1_1StorageComponent.html" title="Component that keeps an alert::Storage storage for fired alerts.">alerts::StorageComponent</a>, which can be accessed from outside using the optional <a class="el" href="../../d6/d08/classalerts_1_1Handler.html" title="Handler that returns the list of active fired alerts.">alerts::Handler</a> component</li>
</ol>
<p>If the config service is not accessible at this point (down or overloaded), then the periodic config update will also obviously fail.</p>
<p>After a config update failure, if the service has already started, then it will keep using the previous successfully fetched configs. Also, you can monitor config update health using</p>
<div class="fragment"><div class="line">cache.any.time.time-from-last-successful-start-ms: cache_name=dynamic-config-client-updater</div>
</div><!-- fragment --><p>and related metrics.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/dac/md_en_2userver_2service__monitor.html">Service Statistics and Metrics (Prometheus/Graphite/...)</a></dd></dl>
<p>If the first config update fails, then the service will read the config cache file specified in <code>dynamic-config.fs-cache-path</code>, which is hopefully left since the previous service start.</p>
<p>If the first config update fails, and the config cache file is missing, then the service will fail to start, showing a helpful log message. Defaults are not used in this case, because they may be significantly outdated, and to avoid requiring the developer to always keep defaults up-to-date with production requirements. Another reason for such behavior is that the dynamic configs are used to fix up incidents, so such check of the dynamic configs service at first deployment prevents incident escalation due to unnoticed misconfiguration (missing routes to dynamic config service, broken authorization, ...).</p>
<p>If you still wish to boot the service using just dynamic config defaults, you can create a config cache file with contents <code>{}</code>, or bake a config cache file into the service's Docker image.</p>
<p><a class="anchor" id="dynamic_config_unit_tests"></a></p>
<h2><a class="anchor" id="autotoc_md237"></a>
Using dynamic config in unit tests and benchmarks</h2>
<p>Main testing page:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/d70/md_en_2userver_2testing.html">Unit Tests and Benchmarks</a></dd></dl>
<p><a class="el" href="../../d6/dec/classdynamic__config_1_1StorageMock.html" title="Backing storage for dynamic_config::Source in tests and benchmarks.">dynamic_config::StorageMock</a> stores configs for unit tests and benchmarks. It must be kept alive while any <a class="el" href="../../d1/d22/classdynamic__config_1_1Source.html" title="A client for easy dynamic config fetching in components.">dynamic_config::Source</a> or <a class="el" href="../../de/d96/classdynamic__config_1_1Snapshot.html" title="The shared snapshot of dynamic configs. Cheap to copy, even cheaper to move. Thread safe,...">dynamic_config::Snapshot</a> is accessing it.</p>
<p>Test code can obtain the <a class="el" href="#dynamic_config_defaults">default configs</a> using <a class="el" href="../../d5/db8/include_2userver_2dynamic__config_2test__helpers_8hpp.html#a1e720aa48a8d267ac06357752600d7f7" title="Get dynamic_config::Snapshot with built-in defaults for all configs.">dynamic_config::GetDefaultSnapshot</a> or <a class="el" href="../../d5/db8/include_2userver_2dynamic__config_2test__helpers_8hpp.html#a1621a144b3f2d8a09062ddd86c9803eb" title="Get dynamic_config::Source with built-in defaults for all configs.">dynamic_config::GetDefaultSource</a>, or override some configs using <a class="el" href="../../d5/db8/include_2userver_2dynamic__config_2test__helpers_8hpp.html#aa771b4a3b0a787b306fa792ed0424592" title="Make dynamic_config::StorageMock with built-in defaults for all configs.">dynamic_config::MakeDefaultStorage</a>.</p>
<p><a class="anchor" id="dynamic_config_testsuite"></a></p>
<h2><a class="anchor" id="autotoc_md238"></a>
Using dynamic config in testsuite</h2>
<p>Main testsuite page:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d07/md_en_2userver_2functional__testing.html">Functional service tests (testsuite)</a></dd></dl>
<h3><a class="anchor" id="autotoc_md239"></a>
Overriding dynamic config for testsuite globally</h3>
<p>Dynamic config can be overridden specifically for testsuite. It can be done globally in the following ways:</p>
<ol type="1">
<li>Providing a JSON file with <code>--config-fallback</code> option to pytest. When using <code>userver_testsuite_add_simple</code> to setup tests in CMake, it is enough to place the <code>dynamic_config_fallback.json</code> file next to the static config.</li>
<li>Providing a patch directly in "Python JSON" format by overriding dynamic_config_fallback_patch fixture</li>
</ol>
<p>The various config patches are applied in the following order, going from the lowest to the highest priority:</p>
<ol type="1">
<li>In-code defaults from <a class="el" href="#dynamic_config_key">dynamic_config::Key</a></li>
<li><code>dynamic-config.defaults</code> option from <a class="el" href="#dynamic_config_defaults_override">static config</a> , if any</li>
<li>JSON file passed to <code>--config-fallback</code>, if any</li>
<li><code>dynamic_config_fallback_patch</code>, if any</li>
</ol>
<h3><a class="anchor" id="autotoc_md240"></a>
Changing dynamic configs in testsuite per test</h3>
<p>If the service has <a class="el" href="#dynamic_config_updates">config updates</a> disabled, then there is no way to change configs per-test. You can resort to creating multiple separate directories for testsuite tests and overriding the initial dynamic config (as shown above) in each of those directories in different ways.</p>
<p>If the service has config updates enabled, then you can change dynamic config per-test as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@pytest.mark.config(MY_CONFIG_NAME=42, MY_OTHER_CONFIG_NAME=True)</span></div>
<div class="line"><span class="keyword">async def </span>test_whatever(service_client, ...):</div>
</div><!-- fragment --><p>Dynamic config can also be modified mid-test using dynamic_config fixture.</p>
<p>Such dynamic config changes are applied (sent to the service) at the first <code>service_client</code> request in the test, or manually:</p>
<div class="fragment"><div class="line">await service_client.update_server_state()</div>
</div><!-- fragment --><hr  />
<p> <div class="bottom-nav">  ⇦ <a class="el" href="../../dd/de2/rabbitmq_driver.html">RabbitMQ (AMQP 0-9-1)</a> | <a class="el" href="../../de/d10/md_en_2schemas_2dynamic__configs.html">Dynamic config schemas</a> ⇨  </div>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:55:59 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
