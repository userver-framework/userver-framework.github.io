<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
        ym(94541714, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/94541714" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=9"/>
      <meta name="generator" content="Doxygen 1.10.0"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <meta property="og:image" content="../../logo_in_circle.png"/>
      <meta property="og:image:alt" content="userver logo"/>
      <link rel="icon" href="../../favicon.svg">
      <title>userver: Concurrency</title>
      <!-- Roboto fonts -->
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
      <!-- Roboto fonts -->
      <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
      <script type="text/javascript" src="../../jquery.js"></script>
      <!-- Highlight.js -->
      <link rel="stylesheet" href="../../highlightjs.css">
      <script src="../../highlight.min.js"></script>
      <!-- Highlight.js -->
      <!-- Roboto fonts -->
      <script type="text/javascript" src="../../dynsections.js"></script>
      <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
      <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
      <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
      <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
      <link rel="stylesheet" href="../../customdoxygen.css">
      <!-- Doxygen Awesome -->
      <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
      <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
      <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.topOffset = 180;
      </script>
      <!-- Doxygen Awesome -->
    </head>
    <body>
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0" style="width: 100%;">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
                <td id="projectalign">
                  <div id="projectname">
                    <a class="titlelink" href="../../index.html">userver
                    </a>
                  </div>
                  <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework</a></div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/db7/group__userver__concurrency.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Concurrency</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Task construction and <a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">synchronization primitives for coroutines</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:d5/d6c/atomic_8hpp" id="r_d5/d6c/atomic_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6c/atomic_8hpp.html">atomic.hpp</a></td></tr>
<tr class="memdesc:d5/d6c/atomic_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algorithms to work with atomics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dac/classutils_1_1TokenBucket.html">utils::TokenBucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d38/classconcurrent_1_1AsyncEventChannel.html">concurrent::AsyncEventChannel&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d11/classconcurrent_1_1AsyncEventSource.html">concurrent::AsyncEventSource&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The read-only side of an event channel. Events are delivered to listeners in a strict FIFO order, i.e. only after the event was processed a new event may appear for processing, same listener is never called concurrently.  <a href="../../dc/d11/classconcurrent_1_1AsyncEventSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d0a/classconcurrent_1_1BackgroundTaskStorageCore.html">concurrent::BackgroundTaskStorageCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc7/classconcurrent_1_1BackgroundTaskStorage.html">concurrent::BackgroundTaskStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d89/classconcurrent_1_1ConflatedEventChannel.html">concurrent::ConflatedEventChannel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-blocking version of '<a class="el" href="../../d6/d38/classconcurrent_1_1AsyncEventChannel.html">AsyncEventChannel</a>'.  <a href="../../d2/d89/classconcurrent_1_1ConflatedEventChannel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d09/classconcurrent_1_1MutexSet.html">concurrent::MutexSet&lt; Key, Hash, Equal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic set of mutexes.  <a href="../../d5/d09/classconcurrent_1_1MutexSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db6/classconcurrent_1_1StripedCounter.html">concurrent::StripedCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contention-free sharded atomic counter, with memory consumption and read performance traded for write performance. Intended to be used for write-heavy counters, mostly in metrics.  <a href="../../d2/db6/classconcurrent_1_1StripedCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable&lt; Data, Mutex &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8e/classdist__lock_1_1DistLockStrategyBase.html">dist_lock::DistLockStrategyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for distributed lock strategies.  <a href="../../d9/d8e/classdist__lock_1_1DistLockStrategyBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9d/classdist__lock_1_1DistLockedTask.html">dist_lock::DistLockedTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task that tries to acquire a distributed lock and runs user callback once while the lock is held.  <a href="../../db/d9d/classdist__lock_1_1DistLockedTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/classdrivers_1_1SubscribableFutureWrapper.html">drivers::SubscribableFutureWrapper&lt; SubscribableFuture &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor for working with certain external futures.  <a href="../../df/db9/classdrivers_1_1SubscribableFutureWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5d/classengine_1_1ConditionVariable.html">engine::ConditionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::condition_variable replacement for asynchronous tasks  <a href="../../d3/d5d/classengine_1_1ConditionVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2e/classengine_1_1Promise.html">engine::Promise&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::promise replacement for asynchronous tasks that works in pair with <a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a>  <a href="../../d9/d2e/classengine_1_1Promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d67/classengine_1_1Future.html">engine::Future&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::future replacement for asynchronous tasks that works in pair with <a class="el" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise</a>  <a href="../../d8/d67/classengine_1_1Future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da4/classengine_1_1Mutex.html">engine::Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::mutex replacement for asynchronous tasks.  <a href="../../d0/da4/classengine_1_1Mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/def/classengine_1_1CancellableSemaphore.html">engine::CancellableSemaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows up to <code>max_simultaneous_locks</code> concurrent accesses to the critical section. It honours task cancellation, unlike <a class="el" href="../../db/d16/classengine_1_1Semaphore.html" title="Class that allows up to max_simultaneous_locks concurrent accesses to the critical section....">Semaphore</a>.  <a href="../../de/def/classengine_1_1CancellableSemaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d16/classengine_1_1Semaphore.html">engine::Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows up to <code>max_simultaneous_locks</code> concurrent accesses to the critical section. It ignores task cancellation, unlike <a class="el" href="../../de/def/classengine_1_1CancellableSemaphore.html" title="Class that allows up to max_simultaneous_locks concurrent accesses to the critical section....">CancellableSemaphore</a>.  <a href="../../db/d16/classengine_1_1Semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html">engine::SharedMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::shared_mutex replacement for asynchronous tasks.  <a href="../../d6/d70/classengine_1_1SharedMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d87/classengine_1_1SingleConsumerEvent.html">engine::SingleConsumerEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiple-producers, single-consumer event.  <a href="../../d8/d87/classengine_1_1SingleConsumerEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dde/classengine_1_1SingleUseEvent.html">engine::SingleUseEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-producer, single-consumer event.  <a href="../../dc/dde/classengine_1_1SingleUseEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd4/classengine_1_1SingleWaitingTaskMutex.html">engine::SingleWaitingTaskMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lighter version of <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks.">Mutex</a> with not more than 1 waiting task.  <a href="../../d8/dd4/classengine_1_1SingleWaitingTaskMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html">engine::TaskInheritedVariable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html" title="TaskInheritedVariable is a per-coroutine variable of arbitrary type.">TaskInheritedVariable</a> is a per-coroutine variable of arbitrary type.  <a href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d40/classengine_1_1TaskLocalVariable.html">engine::TaskLocalVariable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d40/classengine_1_1TaskLocalVariable.html" title="TaskLocalVariable is a per-coroutine variable of arbitrary type.">TaskLocalVariable</a> is a per-coroutine variable of arbitrary type.  <a href="../../d0/d40/classengine_1_1TaskLocalVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html">rcu::Variable&lt; T, RcuTraits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-Copy-Update variable.  <a href="../../d8/d5a/classrcu_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1f/classrcu_1_1RcuMap.html">rcu::RcuMap&lt; Key, Value, RcuMapTraits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-like structure allowing RCU keyset updates.  <a href="../../d0/d1f/classrcu_1_1RcuMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d10/classutils_1_1PeriodicTask.html">utils::PeriodicTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task that periodically runs a user callback. Callback is started after the previous callback execution is finished every <code>period + A - B</code>, where:  <a href="../../d6/d10/classutils_1_1PeriodicTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga564b6fabf9ca1dc0dfa7c5ec3f3172ef" id="r_ga564b6fabf9ca1dc0dfa7c5ec3f3172ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga564b6fabf9ca1dc0dfa7c5ec3f3172ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga564b6fabf9ca1dc0dfa7c5ec3f3172ef">concurrent::NonFifoMpmcQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;true, true&gt;&gt;</td></tr>
<tr class="memdesc:ga564b6fabf9ca1dc0dfa7c5ec3f3172ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non FIFO multiple producers multiple consumers queue.  <br /></td></tr>
<tr class="separator:ga564b6fabf9ca1dc0dfa7c5ec3f3172ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932e4409d1cd0c740a04567c0b778efd" id="r_ga932e4409d1cd0c740a04567c0b778efd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga932e4409d1cd0c740a04567c0b778efd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga932e4409d1cd0c740a04567c0b778efd">concurrent::NonFifoMpscQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;true, false&gt;&gt;</td></tr>
<tr class="memdesc:ga932e4409d1cd0c740a04567c0b778efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non FIFO multiple producers single consumer queue.  <br /></td></tr>
<tr class="separator:ga932e4409d1cd0c740a04567c0b778efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ba33f3d929534956f5fda667ba32dc" id="r_gad3ba33f3d929534956f5fda667ba32dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad3ba33f3d929534956f5fda667ba32dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad3ba33f3d929534956f5fda667ba32dc">concurrent::SpmcQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;false, true&gt;&gt;</td></tr>
<tr class="memdesc:gad3ba33f3d929534956f5fda667ba32dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single producer multiple consumers queue.  <br /></td></tr>
<tr class="separator:gad3ba33f3d929534956f5fda667ba32dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9856ce2c9662e47a69725e04aa9e5c" id="r_ga1f9856ce2c9662e47a69725e04aa9e5c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1f9856ce2c9662e47a69725e04aa9e5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f9856ce2c9662e47a69725e04aa9e5c">concurrent::SpscQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;false, false&gt;&gt;</td></tr>
<tr class="memdesc:ga1f9856ce2c9662e47a69725e04aa9e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single producer single consumer queue.  <br /></td></tr>
<tr class="separator:ga1f9856ce2c9662e47a69725e04aa9e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24465b72cfc96b187a1e2666c6326ce5" id="r_ga24465b72cfc96b187a1e2666c6326ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24465b72cfc96b187a1e2666c6326ce5">concurrent::StringStreamQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;std::string, impl::ContainerQueuePolicy&lt;false, false&gt;&gt;</td></tr>
<tr class="memdesc:ga24465b72cfc96b187a1e2666c6326ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single producer single consumer queue of std::string which is bounded bytes inside.  <br /></td></tr>
<tr class="separator:ga24465b72cfc96b187a1e2666c6326ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae8d31170b5fd287e92a4e0a527ac3575" id="r_gae8d31170b5fd287e92a4e0a527ac3575"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T , <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">Func</a> &gt; </td></tr>
<tr class="memitem:gae8d31170b5fd287e92a4e0a527ac3575"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae8d31170b5fd287e92a4e0a527ac3575">utils::AtomicUpdate</a> (std::atomic&lt; T &gt; &amp;atomic, <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">Func</a> <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">updater</a>)</td></tr>
<tr class="memdesc:gae8d31170b5fd287e92a4e0a527ac3575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs the operation of <code>updater</code> on <code>atomic</code>  <br /></td></tr>
<tr class="separator:gae8d31170b5fd287e92a4e0a527ac3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f07eaf8f0fa0d5907c8c806ecd6f20" id="r_ga07f07eaf8f0fa0d5907c8c806ecd6f20"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T &gt; </td></tr>
<tr class="memitem:ga07f07eaf8f0fa0d5907c8c806ecd6f20"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga07f07eaf8f0fa0d5907c8c806ecd6f20">utils::AtomicMin</a> (std::atomic&lt; T &gt; &amp;atomic, T value)</td></tr>
<tr class="memdesc:ga07f07eaf8f0fa0d5907c8c806ecd6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrently safe sets <code>atomic</code> to a <code>value</code> if <code>value</code> is less.  <br /></td></tr>
<tr class="separator:ga07f07eaf8f0fa0d5907c8c806ecd6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51ba47af7fc25b21c86e2603f0d7f55" id="r_gaf51ba47af7fc25b21c86e2603f0d7f55"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T &gt; </td></tr>
<tr class="memitem:gaf51ba47af7fc25b21c86e2603f0d7f55"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf51ba47af7fc25b21c86e2603f0d7f55">utils::AtomicMax</a> (std::atomic&lt; T &gt; &amp;atomic, T value)</td></tr>
<tr class="memdesc:gaf51ba47af7fc25b21c86e2603f0d7f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrently safe sets <code>atomic</code> to a <code>value</code> if <code>value</code> is greater.  <br /></td></tr>
<tr class="separator:gaf51ba47af7fc25b21c86e2603f0d7f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf870021139920ee54a13682178a0c0c" id="r_gaaf870021139920ee54a13682178a0c0c"><td class="memTemplParams" colspan="2">template&lt;typename SubscribableFuture &gt; </td></tr>
<tr class="memitem:gaaf870021139920ee54a13682178a0c0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaaf870021139920ee54a13682178a0c0c">drivers::WaitForSubscribableFuture</a> (SubscribableFuture &amp;&amp;future)</td></tr>
<tr class="memdesc:gaaf870021139920ee54a13682178a0c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits on the given future as described on <a class="el" href="../../df/db9/classdrivers_1_1SubscribableFutureWrapper.html" title="An adaptor for working with certain external futures.">drivers::SubscribableFutureWrapper</a>.  <br /></td></tr>
<tr class="separator:gaaf870021139920ee54a13682178a0c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f677700ca4b984ca942f23af8649c8" id="r_gaa1f677700ca4b984ca942f23af8649c8"><td class="memTemplParams" colspan="2">template&lt;typename SubscribableFuture &gt; </td></tr>
<tr class="memitem:gaa1f677700ca4b984ca942f23af8649c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2">engine::FutureStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa1f677700ca4b984ca942f23af8649c8">drivers::TryWaitForSubscribableFuture</a> (SubscribableFuture &amp;&amp;future, <a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a> deadline)</td></tr>
<tr class="separator:gaa1f677700ca4b984ca942f23af8649c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c1ba3047210ae48bbc0f027fedd31c" id="r_ga26c1ba3047210ae48bbc0f027fedd31c"><td class="memTemplParams" colspan="2">template&lt;typename... Tasks&gt; </td></tr>
<tr class="memitem:ga26c1ba3047210ae48bbc0f027fedd31c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga26c1ba3047210ae48bbc0f027fedd31c">engine::GetAll</a> (Tasks &amp;... tasks)</td></tr>
<tr class="memdesc:ga26c1ba3047210ae48bbc0f027fedd31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the successful completion of all of the specified tasks or the cancellation of the caller.  <br /></td></tr>
<tr class="separator:ga26c1ba3047210ae48bbc0f027fedd31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a0b9edf6e9e23e3433edafc6d59279" id="r_gae7a0b9edf6e9e23e3433edafc6d59279"><td class="memTemplParams" colspan="2">template&lt;typename... Tasks&gt; </td></tr>
<tr class="memitem:gae7a0b9edf6e9e23e3433edafc6d59279"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae7a0b9edf6e9e23e3433edafc6d59279">engine::WaitAllChecked</a> (Tasks &amp;... tasks)</td></tr>
<tr class="memdesc:gae7a0b9edf6e9e23e3433edafc6d59279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the successful completion of all of the specified tasks or for the cancellation of the caller.  <br /></td></tr>
<tr class="separator:gae7a0b9edf6e9e23e3433edafc6d59279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc06edbfecd5d58598fb3880ae9edb2" id="r_ga6fc06edbfecd5d58598fb3880ae9edb2"><td class="memTemplParams" colspan="2">template&lt;typename... Tasks&gt; </td></tr>
<tr class="memitem:ga6fc06edbfecd5d58598fb3880ae9edb2"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6fc06edbfecd5d58598fb3880ae9edb2">engine::WaitAny</a> (Tasks &amp;... tasks)</td></tr>
<tr class="memdesc:ga6fc06edbfecd5d58598fb3880ae9edb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the completion of any of the specified tasks or the cancellation of the caller.  <br /></td></tr>
<tr class="separator:ga6fc06edbfecd5d58598fb3880ae9edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b9a09eacda1ddf8b4440b3713f5e52" id="r_ga29b9a09eacda1ddf8b4440b3713f5e52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga29b9a09eacda1ddf8b4440b3713f5e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga29b9a09eacda1ddf8b4440b3713f5e52">utils::Async</a> (std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="memdesc:ga29b9a09eacda1ddf8b4440b3713f5e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous task.  <br /></td></tr>
<tr class="separator:ga29b9a09eacda1ddf8b4440b3713f5e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91f56844690ea79c568cb3b43ba98a5" id="r_gac91f56844690ea79c568cb3b43ba98a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gac91f56844690ea79c568cb3b43ba98a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a> (engine::TaskProcessor &amp;task_processor, std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gac91f56844690ea79c568cb3b43ba98a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9a6bb83cc055693bd116a503434eeb" id="r_gaef9a6bb83cc055693bd116a503434eeb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gaef9a6bb83cc055693bd116a503434eeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaef9a6bb83cc055693bd116a503434eeb">utils::CriticalAsync</a> (engine::TaskProcessor &amp;task_processor, std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gaef9a6bb83cc055693bd116a503434eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d59530e8c77058b20607b007a7c208" id="r_ga61d59530e8c77058b20607b007a7c208"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga61d59530e8c77058b20607b007a7c208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga61d59530e8c77058b20607b007a7c208">utils::SharedCriticalAsync</a> (engine::TaskProcessor &amp;task_processor, std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga61d59530e8c77058b20607b007a7c208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3eda3f32d025bb1f9b0ed183f4d701" id="r_ga5c3eda3f32d025bb1f9b0ed183f4d701"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga5c3eda3f32d025bb1f9b0ed183f4d701"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5c3eda3f32d025bb1f9b0ed183f4d701">utils::SharedAsync</a> (engine::TaskProcessor &amp;task_processor, std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga5c3eda3f32d025bb1f9b0ed183f4d701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565a66b920bca5b747d228cfe07752ac" id="r_ga565a66b920bca5b747d228cfe07752ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga565a66b920bca5b747d228cfe07752ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga565a66b920bca5b747d228cfe07752ac">utils::Async</a> (engine::TaskProcessor &amp;task_processor, std::string name, <a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a> deadline, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga565a66b920bca5b747d228cfe07752ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcc0a74c7b8f24f3df12d761997fdc9" id="r_gabdcc0a74c7b8f24f3df12d761997fdc9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gabdcc0a74c7b8f24f3df12d761997fdc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabdcc0a74c7b8f24f3df12d761997fdc9">utils::SharedAsync</a> (engine::TaskProcessor &amp;task_processor, std::string name, <a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a> deadline, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gabdcc0a74c7b8f24f3df12d761997fdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154477640bae76b7d0f3b68e4c554fad" id="r_ga154477640bae76b7d0f3b68e4c554fad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga154477640bae76b7d0f3b68e4c554fad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga154477640bae76b7d0f3b68e4c554fad">utils::CriticalAsync</a> (std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga154477640bae76b7d0f3b68e4c554fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1173247486e8989f98ec07ac17c470b7" id="r_ga1173247486e8989f98ec07ac17c470b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga1173247486e8989f98ec07ac17c470b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1173247486e8989f98ec07ac17c470b7">utils::SharedCriticalAsync</a> (std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga1173247486e8989f98ec07ac17c470b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748493b457906d30c7888be4541bd6e8" id="r_ga748493b457906d30c7888be4541bd6e8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga748493b457906d30c7888be4541bd6e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga748493b457906d30c7888be4541bd6e8">utils::SharedAsync</a> (std::string name, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga748493b457906d30c7888be4541bd6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95dc7e03073d913e5c68dbf4c849521" id="r_gab95dc7e03073d913e5c68dbf4c849521"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gab95dc7e03073d913e5c68dbf4c849521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab95dc7e03073d913e5c68dbf4c849521">utils::Async</a> (std::string name, <a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a> deadline, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gab95dc7e03073d913e5c68dbf4c849521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f0af163f6bf9146f9f3dd39dad5274" id="r_ga01f0af163f6bf9146f9f3dd39dad5274"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:ga01f0af163f6bf9146f9f3dd39dad5274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga01f0af163f6bf9146f9f3dd39dad5274">utils::SharedAsync</a> (std::string name, <a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a> deadline, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:ga01f0af163f6bf9146f9f3dd39dad5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62af0c792f9f807a8667c0471dbf448" id="r_gaa62af0c792f9f807a8667c0471dbf448"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gaa62af0c792f9f807a8667c0471dbf448"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa62af0c792f9f807a8667c0471dbf448">utils::AsyncBackground</a> (std::string name, engine::TaskProcessor &amp;task_processor, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gaa62af0c792f9f807a8667c0471dbf448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd5a015f578e44b279cfc83944f6b52" id="r_gaabd5a015f578e44b279cfc83944f6b52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </td></tr>
<tr class="memitem:gaabd5a015f578e44b279cfc83944f6b52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaabd5a015f578e44b279cfc83944f6b52">utils::CriticalAsyncBackground</a> (std::string name, engine::TaskProcessor &amp;task_processor, Function &amp;&amp;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">f</a>, Args &amp;&amp;... <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">args</a>)</td></tr>
<tr class="separator:gaabd5a015f578e44b279cfc83944f6b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga564b6fabf9ca1dc0dfa7c5ec3f3172ef" name="ga564b6fabf9ca1dc0dfa7c5ec3f3172ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga564b6fabf9ca1dc0dfa7c5ec3f3172ef">&#9670;&#160;</a></span>NonFifoMpmcQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga564b6fabf9ca1dc0dfa7c5ec3f3172ef">concurrent::NonFifoMpmcQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;true, true&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non FIFO multiple producers multiple consumers queue. </p>
<p>Items from the same producer are always delivered in the production order. Items from different producers (or when using a <code>MultiProducer</code> token) are delivered in an unspecified order. In other words, FIFO order is maintained only within producers, but not between them. This may lead to increased peak latency of item processing.</p>
<p>In exchange for this, the queue has lower contention and increased throughput compared to a conventional lock-free queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">Synchronization Primitives</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ded/queue_8hpp_source.html#l00587">587</a> of file <a class="el" href="../../d7/ded/queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ga932e4409d1cd0c740a04567c0b778efd" name="ga932e4409d1cd0c740a04567c0b778efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932e4409d1cd0c740a04567c0b778efd">&#9670;&#160;</a></span>NonFifoMpscQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga932e4409d1cd0c740a04567c0b778efd">concurrent::NonFifoMpscQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;true, false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non FIFO multiple producers single consumer queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga564b6fabf9ca1dc0dfa7c5ec3f3172ef" title="Non FIFO multiple producers multiple consumers queue.">concurrent::NonFifoMpmcQueue</a> for the description of what NonFifo means. </dd>
<dd>
<a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">Synchronization Primitives</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ded/queue_8hpp_source.html#l00596">596</a> of file <a class="el" href="../../d7/ded/queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="gad3ba33f3d929534956f5fda667ba32dc" name="gad3ba33f3d929534956f5fda667ba32dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ba33f3d929534956f5fda667ba32dc">&#9670;&#160;</a></span>SpmcQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gad3ba33f3d929534956f5fda667ba32dc">concurrent::SpmcQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;false, true&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single producer multiple consumers queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">Synchronization Primitives</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ded/queue_8hpp_source.html#l00604">604</a> of file <a class="el" href="../../d7/ded/queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ga1f9856ce2c9662e47a69725e04aa9e5c" name="ga1f9856ce2c9662e47a69725e04aa9e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9856ce2c9662e47a69725e04aa9e5c">&#9670;&#160;</a></span>SpscQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga1f9856ce2c9662e47a69725e04aa9e5c">concurrent::SpscQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;T, impl::SimpleQueuePolicy&lt;false, false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single producer single consumer queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">Synchronization Primitives</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ded/queue_8hpp_source.html#l00612">612</a> of file <a class="el" href="../../d7/ded/queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ga24465b72cfc96b187a1e2666c6326ce5" name="ga24465b72cfc96b187a1e2666c6326ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24465b72cfc96b187a1e2666c6326ce5">&#9670;&#160;</a></span>StringStreamQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga24465b72cfc96b187a1e2666c6326ce5">concurrent::StringStreamQueue</a> = <a class="el" href="../../d8/d97/classconcurrent_1_1GenericQueue.html">GenericQueue</a>&lt;std::string, impl::ContainerQueuePolicy&lt;false, false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single producer single consumer queue of std::string which is bounded bytes inside. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d6/d6c/md_en_2userver_2synchronization.html">Synchronization Primitives</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/ded/queue_8hpp_source.html#l00620">620</a> of file <a class="el" href="../../d7/ded/queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga565a66b920bca5b747d228cfe07752ac" name="ga565a66b920bca5b747d228cfe07752ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565a66b920bca5b747d228cfe07752ac">&#9670;&#160;</a></span>Async() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::Async </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00315">315</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gac91f56844690ea79c568cb3b43ba98a5" name="gac91f56844690ea79c568cb3b43ba98a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac91f56844690ea79c568cb3b43ba98a5">&#9670;&#160;</a></span>Async() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::Async </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00241">241</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gab95dc7e03073d913e5c68dbf4c849521" name="gab95dc7e03073d913e5c68dbf4c849521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95dc7e03073d913e5c68dbf4c849521">&#9670;&#160;</a></span>Async() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::Async </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00430">430</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga29b9a09eacda1ddf8b4440b3713f5e52" name="ga29b9a09eacda1ddf8b4440b3713f5e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29b9a09eacda1ddf8b4440b3713f5e52">&#9670;&#160;</a></span>Async() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::Async </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous task. </p>
<p>By default, arguments are copied or moved inside the resulting <code>TaskWithResult</code>, like <code>std::thread</code> does. To pass an argument by reference, wrap it in <code>std::ref / std::cref</code> or capture the arguments using a lambda.</p>
<p><a class="anchor" id="flavors_of_async"></a></p>
<h2><a class="anchor" id="autotoc_md1002"></a>
Flavors of <code>Async</code></h2>
<p>There are multiple orthogonal parameters of the task being started. Use this specific overload by default (<code><a class="el" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a></code>).</p>
<p>By engine::TaskProcessor:</p>
<ul>
<li>By default, task processor of the current task is used.</li>
<li>Custom task processor can be passed as the first or second function parameter (see function signatures).</li>
</ul>
<p>By shared-ness:</p>
<ul>
<li>By default, functions return <a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a>, which can be awaited from 1 task at once. This is a reasonable choice for most cases.</li>
<li>Functions from <code><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">utils::Shared</a>*Async*</code> and <code>engine::Shared*AsyncNoSpan</code> families return <a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a>, which can be awaited from multiple tasks at the same time, at the cost of some overhead.</li>
</ul>
<p>By <a class="el" href="../../d5/d4b/classengine_1_1TaskBase.html#ac4769fc23b14426907e47e79b8c99eeb" title="Task importance.">engine::TaskBase::Importance</a> ("critical-ness"):</p>
<ul>
<li>By default, functions can be cancelled due to engine::TaskProcessor overload. Also, if the task is cancelled before being started, it will not run at all.</li>
<li>If the whole service's health (not just one request) depends on the task being run, then functions from <code>utils::*CriticalAsync*</code> and <code>engine::*CriticalAsyncNoSpan*</code> families can be used. There, execution of the function is guaranteed to start regardless of engine::TaskProcessor load limits</li>
</ul>
<p>By <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a>:</p>
<ul>
<li>Functions from <code>utils::*Async*</code> family (which you should use by default) create <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> with inherited <code>trace_id</code> and <code>link</code>, a new <code>span_id</code> and the specified <code>stopwatch_name</code>, which ensures that logs from the task are categorized correctly and will not get lost.</li>
<li>Functions from <code>engine::*AsyncNoSpan*</code> family create span-less tasks:<ul>
<li>A possible usage scenario is to create a task that will mostly wait in the background and do various unrelated work every now and then. In this case it might make sense to trace execution of work items, but not of the task itself.</li>
<li>Its usage can (albeit very rarely) be justified to squeeze some nanoseconds of performance where no logging is expected. But beware! Using <a class="el" href="../../d7/d1a/classtracing_1_1Span.html#aba13e9517b52eecb30cd30320f82b32d" title="Returns the Span of the current task.">tracing::Span::CurrentSpan()</a> will trigger asserts and lead to UB in production.</li>
</ul>
</li>
</ul>
<p>By the propagation of <a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html" title="TaskInheritedVariable is a per-coroutine variable of arbitrary type.">engine::TaskInheritedVariable</a> instances:</p>
<ul>
<li>Functions from <code>utils::*Async*</code> family (which you should use by default) inherit all task-inherited variables from the parent task.</li>
<li>Functions from <code>engine::*AsyncNoSpan*</code> family do not inherit any task-inherited variables.</li>
</ul>
<p>By deadline: some <code>utils::*Async*</code> functions accept an <code><a class="el" href="../../de/d6a/classengine_1_1Deadline.html" title="Internal representation of a deadline time point.">engine::Deadline</a></code> parameter. If the deadline expires, the task is cancelled. See <code>*Async*</code> function signatures for details.</p>
<h2><a class="anchor" id="autotoc_md1003"></a>
Lifetime of captures</h2>
<dl class="section note"><dt>Note</dt><dd>To launch background tasks, which are not awaited in the local scope, use <a class="el" href="../../d0/dc7/classconcurrent_1_1BackgroundTaskStorage.html">concurrent::BackgroundTaskStorage</a>.</dd></dl>
<p>When launching a task, it's important to ensure that it will not access its lambda captures after they are destroyed. Plain data captured by value (including by move) is always safe. By-reference captures and objects that store references inside are always something to be aware of. Of course, copying the world will degrade performance, so let's see how to ensure lifetime safety with captured references.</p>
<p>Task objects are automatically cancelled and awaited on destruction, if not already finished. The lifetime of the task object is what determines when the task may be running and accessing its captures. The task can only safely capture by reference objects that outlive the task object.</p>
<p>When the task is just stored in a new local variable and is not moved or returned from a function, capturing anything is safe:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> x{};</div>
<div class="line"><span class="keywordtype">int</span> y{};</div>
<div class="line"><span class="comment">// It&#39;s recommended to write out captures explicitly when launching tasks.</span></div>
<div class="line"><span class="keyword">auto</span> task = <a class="code hl_function" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;frobnicate&quot;</span>, [&amp;x, &amp;y] {</div>
<div class="line">  <span class="comment">// Capturing anything defined before the `task` variable is safe.</span></div>
<div class="line">  Use(x, y);</div>
<div class="line">});</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">task.Get();</div>
</div><!-- fragment --><p>A more complicated example, where the task is moved into a container:</p>
<div class="fragment"><div class="line"><span class="comment">// Variables are destroyed in the reverse definition order: y, tasks, x.</span></div>
<div class="line"><span class="keywordtype">int</span> x{};</div>
<div class="line">std::vector&lt;engine::TaskWithResult&lt;void&gt;&gt; <a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">tasks</a>;</div>
<div class="line"><span class="keywordtype">int</span> y{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">tasks</a>.push_back(<a class="code hl_function" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;frobnicate&quot;</span>, [&amp;x, &amp;y] {</div>
<div class="line">  <span class="comment">// Capturing x is safe, because `tasks` outlives `x`.</span></div>
<div class="line">  Use(x);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// BUG! The task may keep running for some time after `y` is destroyed.</span></div>
<div class="line">  Use(y);</div>
<div class="line">}));</div>
</div><!-- fragment --><p>The bug above can be fixed by placing the declaration of <code>tasks</code> after <code>y</code>.</p>
<p>In the case above people often think that calling <code>.Get()</code> in appropriate places solves the problem. It does not! If an exception is thrown somewhere before <code>.Get()</code>, then the variables' definition order is the source of truth.</p>
<p>Same guidelines apply when tasks are stored in classes or structs: the task object must be defined below everything that it accesses:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line"> <a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">Foo</a> <a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">foo_</a>;</div>
<div class="line"> <span class="comment">// Can access foo_ but not bar_.</span></div>
<div class="line"> <a class="code hl_class" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult&lt;void&gt;</a> task_;</div>
<div class="line"> <a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">Bar</a> <a class="code hl_function" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779" title="Extract the number contained in the string. No space characters or other extra characters allowed....">bar_</a>;</div>
</div><!-- fragment --><p>Generally, it's a good idea to put task objects as low as possible in the list of class members.</p>
<p>Although, tasks are rarely stored in classes on practice, <a class="el" href="../../d0/dc7/classconcurrent_1_1BackgroundTaskStorage.html">concurrent::BackgroundTaskStorage</a> is typically used for that purpose.</p>
<p>Components and their clients can always be safely captured by reference:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dcc/md_en_2userver_2component__system.html">Component system</a></dd></dl>
<h2><a class="anchor" id="autotoc_md1004"></a>
About this specific overload</h2>
<p>This is the overload that should be used by default.</p>
<ul>
<li>The task will be launched on the current TaskProcessor.</li>
<li>Only 1 task may call <code>Wait</code> or <code>Get</code> on this task.</li>
<li>The task may be cancelled before the function starts execution in case of TaskProcessor overload. Also, if the task is cancelled for any reason before the function starts execution, it will not run at all.</li>
<li>The task will create a child <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> with the specified name</li>
<li>The task will inherit all <a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html" title="TaskInheritedVariable is a per-coroutine variable of arbitrary type.">engine::TaskInheritedVariable</a> instances from the current task.</li>
</ul>
<p>For details on the various other overloads: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#flavors_of_async">flavors_of_async</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d3/d25/components_2component_sample_test_8cpp-example.html#a8">components/component_sample_test.cpp</a>, and <a class="el" href="../../d9/d90/samples_2tcp_full_duplex_service_2tcp_full_duplex_service_8cpp-example.html#a14">samples/tcp_full_duplex_service/tcp_full_duplex_service.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00220">220</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gaa62af0c792f9f807a8667c0471dbf448" name="gaa62af0c792f9f807a8667c0471dbf448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62af0c792f9f807a8667c0471dbf448">&#9670;&#160;</a></span>AsyncBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::AsyncBackground </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an asynchronous task without propagating <a class="el" href="../../d1/d8b/classengine_1_1TaskInheritedVariable.html" title="TaskInheritedVariable is a per-coroutine variable of arbitrary type.">engine::TaskInheritedVariable</a>. <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> and <a class="el" href="../../da/ddf/classbaggage_1_1Baggage.html" title="Baggage header. Contains entries (key, value, optional&lt;properties&gt;).">baggage::Baggage</a> are inherited. Task execution may be cancelled before the function starts execution in case of engine::TaskProcessor overload.</p>
<p>Typically used from a request handler to launch tasks that outlive the request and do not effect its completion.</p>
<h2><a class="anchor" id="autotoc_md1005"></a>
Usage example</h2>
<p>Suppose you have some component that runs asynchronous tasks: </p><div class="fragment"><div class="line"><span class="keyword">class </span>AsyncRequestProcessor final {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AsyncRequestProcessor();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> FooAsync(Request&amp;&amp; request);</div>
<div class="line"> </div>
<div class="line">    Response WaitAndGetAggregate();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> Response Foo(Request&amp;&amp; request);</div>
<div class="line"> </div>
<div class="line">    engine::TaskProcessor&amp; task_processor_;</div>
<div class="line">    <a class="code hl_class" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable&lt;std::vector&lt;engine::TaskWithResult&lt;Response&gt;</a>&gt;&gt; tasks_;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> handler = [&amp;](Request&amp;&amp; request) {</div>
<div class="line">        async_request_processor.FooAsync(std::move(request));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Please wait, your request is being processed.&quot;</span>;</div>
<div class="line">    };</div>
</div><!-- fragment --><p>If the tasks logically belong to the component itself (not to the method caller), then they should be launched using <a class="el" href="#gaa62af0c792f9f807a8667c0471dbf448">utils::AsyncBackground</a> instead of the regular <a class="el" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> AsyncRequestProcessor::FooAsync(Request&amp;&amp; request) {</div>
<div class="line">    <span class="keyword">auto</span> tasks = tasks_.Lock();</div>
<div class="line">    tasks-&gt;push_back(<a class="code hl_function" href="#gaa62af0c792f9f807a8667c0471dbf448">utils::AsyncBackground</a>(<span class="stringliteral">&quot;foo&quot;</span>, task_processor_, &amp;Foo, std::move(request)));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1006"></a>
Arguments</h2>
<p>By default, arguments are copied or moved inside the resulting <code>TaskWithResult</code>, like <code>std::thread</code> does. To pass an argument by reference, wrap it in <code>std::ref / std::cref</code> or capture the arguments using a lambda.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00493">493</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gaf51ba47af7fc25b21c86e2603f0d7f55" name="gaf51ba47af7fc25b21c86e2603f0d7f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51ba47af7fc25b21c86e2603f0d7f55">&#9670;&#160;</a></span>AtomicMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utils::AtomicMax </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atomic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concurrently safe sets <code>atomic</code> to a <code>value</code> if <code>value</code> is greater. </p>
<dl class="section note"><dt>Note</dt><dd>Uses std::memory_order_relaxed </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d6c/atomic_8hpp_source.html#l00053">53</a> of file <a class="el" href="../../d5/d6c/atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="ga07f07eaf8f0fa0d5907c8c806ecd6f20" name="ga07f07eaf8f0fa0d5907c8c806ecd6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07f07eaf8f0fa0d5907c8c806ecd6f20">&#9670;&#160;</a></span>AtomicMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utils::AtomicMin </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atomic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concurrently safe sets <code>atomic</code> to a <code>value</code> if <code>value</code> is less. </p>
<dl class="section note"><dt>Note</dt><dd>Uses std::memory_order_relaxed </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d6c/atomic_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d5/d6c/atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="gae8d31170b5fd287e92a4e0a527ac3575" name="gae8d31170b5fd287e92a4e0a527ac3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d31170b5fd287e92a4e0a527ac3575">&#9670;&#160;</a></span>AtomicUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> T , <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> <a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">Func</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utils::AtomicUpdate </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atomic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">Func</a></td>          <td class="paramname"><span class="paramname"><em>updater</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically performs the operation of <code>updater</code> on <code>atomic</code> </p>
<p><code>updater</code> may be called multiple times per one call of <code>AtomicUpdate</code>, so it must be idempotent. To ensure that the function does not spin for a long time, <code>updater</code> must be fairly simple and fast. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atomic</td><td>the variable to update </td></tr>
    <tr><td class="paramname">updater</td><td>a lambda that takes the old value and produces the new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated value </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses std::memory_order_relaxed </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d6c/atomic_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d5/d6c/atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="gaef9a6bb83cc055693bd116a503434eeb" name="gaef9a6bb83cc055693bd116a503434eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef9a6bb83cc055693bd116a503434eeb">&#9670;&#160;</a></span>CriticalAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::CriticalAsync </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Execution of function is guaranteed to start regardless of engine::TaskProcessor load limits. Prefer <a class="el" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a> by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name for the <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> to use with this task </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00260">260</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga154477640bae76b7d0f3b68e4c554fad" name="ga154477640bae76b7d0f3b68e4c554fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154477640bae76b7d0f3b68e4c554fad">&#9670;&#160;</a></span>CriticalAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::CriticalAsync </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Execution of function is guaranteed to start regardless of engine::TaskProcessor load limits. Prefer <a class="el" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a> by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> to use with this task </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00370">370</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gaabd5a015f578e44b279cfc83944f6b52" name="gaabd5a015f578e44b279cfc83944f6b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabd5a015f578e44b279cfc83944f6b52">&#9670;&#160;</a></span>CriticalAsyncBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::CriticalAsyncBackground </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Execution of function is guaranteed to start regardless of engine::TaskProcessor load limits. Use for background tasks for which failing to start not just breaks handling of a single request, but harms the whole service instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00519">519</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga26c1ba3047210ae48bbc0f027fedd31c" name="ga26c1ba3047210ae48bbc0f027fedd31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c1ba3047210ae48bbc0f027fedd31c">&#9670;&#160;</a></span>GetAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tasks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto engine::GetAll </td>
          <td>(</td>
          <td class="paramtype">Tasks &amp;...</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the successful completion of all of the specified tasks or the cancellation of the caller. </p>
<p>Effectively performs <code>for (auto&amp; task : tasks) task.Get();</code> with a twist: task.Get() is called in tasks completion order rather than in provided order, thus exceptions are rethrown ASAP.</p>
<p>After successful return from this method the tasks are invalid, in case of an exception being thrown some of the tasks might be invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>either a single container, or a pack of future-like elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::vector&lt;Result&gt;</code> or <code>void</code>, depending on the tasks result type (which must be the same for all <code>tasks</code>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dae/classengine_1_1WaitInterruptedException.html">WaitInterruptedException</a></td><td>when <code><a class="el" href="../../d2/d64/namespaceengine_1_1current__task.html#a561f4b1f4b6d9b12f41a8f6a0d98547e">current_task::IsCancelRequested()</a></code> and no TaskCancellationBlockers are present. </td></tr>
    <tr><td class="paramname">std::exception</td><td>rethrows one of specified tasks exception, if any, in no particular order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Has overall computational complexity of O(N^2), where N is the number of tasks. </dd>
<dd>
Prefer <a class="el" href="#gae7a0b9edf6e9e23e3433edafc6d59279" title="Waits for the successful completion of all of the specified tasks or for the cancellation of the call...">engine::WaitAllChecked</a> for tasks with a result, unless you specifically need the results stored in a <code>std::vector</code> or when storing the results long-term. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/d71/get__all_8hpp_source.html#l00084">84</a> of file <a class="el" href="../../db/d71/get__all_8hpp_source.html">get_all.hpp</a>.</p>

</div>
</div>
<a id="gabdcc0a74c7b8f24f3df12d761997fdc9" name="gabdcc0a74c7b8f24f3df12d761997fdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdcc0a74c7b8f24f3df12d761997fdc9">&#9670;&#160;</a></span>SharedAsync() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedAsync </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00343">343</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga5c3eda3f32d025bb1f9b0ed183f4d701" name="ga5c3eda3f32d025bb1f9b0ed183f4d701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c3eda3f32d025bb1f9b0ed183f4d701">&#9670;&#160;</a></span>SharedAsync() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedAsync </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00297">297</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga01f0af163f6bf9146f9f3dd39dad5274" name="ga01f0af163f6bf9146f9f3dd39dad5274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f0af163f6bf9146f9f3dd39dad5274">&#9670;&#160;</a></span>SharedAsync() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedAsync </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00451">451</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga748493b457906d30c7888be4541bd6e8" name="ga748493b457906d30c7888be4541bd6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748493b457906d30c7888be4541bd6e8">&#9670;&#160;</a></span>SharedAsync() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedAsync </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Task execution may be cancelled before the function starts execution in case of TaskProcessor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the task to show in logs </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00410">410</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga61d59530e8c77058b20607b007a7c208" name="ga61d59530e8c77058b20607b007a7c208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d59530e8c77058b20607b007a7c208">&#9670;&#160;</a></span>SharedCriticalAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedCriticalAsync </td>
          <td>(</td>
          <td class="paramtype">engine::TaskProcessor &amp;</td>          <td class="paramname"><span class="paramname"><em>task_processor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Execution of function is guaranteed to start regardless of engine::TaskProcessor load limits. Prefer <a class="el" href="#ga5c3eda3f32d025bb1f9b0ed183f4d701">utils::SharedAsync</a> by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_processor</td><td>Task processor to run on </td></tr>
    <tr><td class="paramname">name</td><td>Name for the <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> to use with this task </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00279">279</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="ga1173247486e8989f98ec07ac17c470b7" name="ga1173247486e8989f98ec07ac17c470b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1173247486e8989f98ec07ac17c470b7">&#9670;&#160;</a></span>SharedCriticalAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">typename</a> Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d84/namespaceutils.html#a703c865514d1d674e7bf30c212cb8779">auto</a> utils::SharedCriticalAsync </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Execution of function is guaranteed to start regardless of engine::TaskProcessor load limits. Prefer <a class="el" href="#ga5c3eda3f32d025bb1f9b0ed183f4d701">utils::SharedAsync</a> by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the <a class="el" href="../../d7/d1a/classtracing_1_1Span.html" title="Measures the execution time of the current code block, links it with the parent tracing::Spans and st...">tracing::Span</a> to use with this task </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute asynchronously </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/d97/classengine_1_1SharedTaskWithResult.html" title="Asynchronous task with result that has a shared ownership of payload.">engine::SharedTaskWithResult</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html#l00390">390</a> of file <a class="el" href="../../de/d4e/utils_2async_8hpp_source.html">async.hpp</a>.</p>

</div>
</div>
<a id="gaa1f677700ca4b984ca942f23af8649c8" name="gaa1f677700ca4b984ca942f23af8649c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f677700ca4b984ca942f23af8649c8">&#9670;&#160;</a></span>TryWaitForSubscribableFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubscribableFuture &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2">engine::FutureStatus</a> drivers::TryWaitForSubscribableFuture </td>
          <td>(</td>
          <td class="paramtype">SubscribableFuture &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>future</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d6a/classengine_1_1Deadline.html">engine::Deadline</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section return"><dt>Returns</dt><dd>an error code if deadline is exceeded or task is cancelled</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Repeatedly waiting again after <code>deadline</code> expiration leads to a memory leak, use <a class="el" href="../../df/db9/classdrivers_1_1SubscribableFutureWrapper.html" title="An adaptor for working with certain external futures.">drivers::SubscribableFutureWrapper</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d01/subscribable__futures_8hpp_source.html#l00097">97</a> of file <a class="el" href="../../d8/d01/subscribable__futures_8hpp_source.html">subscribable_futures.hpp</a>.</p>

</div>
</div>
<a id="gae7a0b9edf6e9e23e3433edafc6d59279" name="gae7a0b9edf6e9e23e3433edafc6d59279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a0b9edf6e9e23e3433edafc6d59279">&#9670;&#160;</a></span>WaitAllChecked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tasks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void engine::WaitAllChecked </td>
          <td>(</td>
          <td class="paramtype">Tasks &amp;...</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the successful completion of all of the specified tasks or for the cancellation of the caller. </p>
<p>Effectively performs <code>for (auto&amp; task : tasks) task.Wait();</code> with a twist: if any task completes with an exception, it gets rethrown ASAP.</p>
<p>Invalid tasks are skipped.</p>
<p>Tasks are not invalidated by <code>WaitAllChecked</code>; the result can be retrieved after the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>either a single container, or a pack of future-like elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dae/classengine_1_1WaitInterruptedException.html">WaitInterruptedException</a></td><td>when <code><a class="el" href="../../d2/d64/namespaceengine_1_1current__task.html#aed8fc1cdfd588f3973f5c9bc503c9986">current_task::ShouldCancel()</a></code> (for WaitAllChecked versions without a deadline) </td></tr>
    <tr><td class="paramname">std::exception</td><td>one of specified tasks exception, if any, in no particular order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Has overall computational complexity of O(N^2), where N is the number of tasks. </dd>
<dd>
Keeping the tasks valid may have a small extra memory impact. Make sure to drop the tasks after reading the results. </dd>
<dd>
Prefer <a class="el" href="#ga26c1ba3047210ae48bbc0f027fedd31c" title="Waits for the successful completion of all of the specified tasks or the cancellation of the caller.">engine::GetAll</a> for tasks without a result, unless you specifically need to keep the tasks alive for some reason. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/d30/wait__all__checked_8hpp_source.html#l00095">95</a> of file <a class="el" href="../../db/d30/wait__all__checked_8hpp_source.html">wait_all_checked.hpp</a>.</p>

</div>
</div>
<a id="ga6fc06edbfecd5d58598fb3880ae9edb2" name="ga6fc06edbfecd5d58598fb3880ae9edb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc06edbfecd5d58598fb3880ae9edb2">&#9670;&#160;</a></span>WaitAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tasks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::size_t &gt; engine::WaitAny </td>
          <td>(</td>
          <td class="paramtype">Tasks &amp;...</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the completion of any of the specified tasks or the cancellation of the caller. </p>
<p>Could be used to get the ready HTTP requests ASAP: </p><div class="fragment"><div class="line">std::size_t ProcessReadyRequests(std::vector&lt;clients::http::ResponseFuture&gt;&amp; requests, <a class="code hl_class" href="../../de/d6a/classengine_1_1Deadline.html" title="Internal representation of a deadline time point.">engine::Deadline</a> deadline) {</div>
<div class="line">    std::size_t processed_requests = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">auto</span> indx = engine::WaitAnyUntil(deadline, requests)) {</div>
<div class="line">        ++processed_requests;</div>
<div class="line"> </div>
<div class="line">        std::shared_ptr&lt;clients::http::Response&gt; response = requests[*indx].Get();</div>
<div class="line">        EXPECT_TRUE(response-&gt;IsOk());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> processed_requests;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Works with different types of tasks and futures: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> task0 = <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#ac249644dedd4351b50adc96c8b76c358" title="Runs an asynchronous function call using specified task processor.">engine::AsyncNoSpan</a>([] { <span class="keywordflow">return</span> 1; });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> task1 = <a class="code hl_function" href="#ga29b9a09eacda1ddf8b4440b3713f5e52" title="Starts an asynchronous task.">utils::Async</a>(<span class="stringliteral">&quot;long_task&quot;</span>, [] {</div>
<div class="line">        <a class="code hl_function" href="../../dc/d3f/namespaceengine.html#a19462f750672c6fa7f5f690c2575b9f6">engine::InterruptibleSleepFor</a>(20s);</div>
<div class="line">        <span class="keywordflow">return</span> std::string{<span class="stringliteral">&quot;abc&quot;</span>};</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> task_idx_opt = <a class="code hl_function" href="#ga6fc06edbfecd5d58598fb3880ae9edb2" title="Waits for the completion of any of the specified tasks or the cancellation of the caller.">engine::WaitAny</a>(task0, task1);</div>
<div class="line">    ASSERT_TRUE(task_idx_opt);</div>
<div class="line">    EXPECT_EQ(*task_idx_opt, 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>either a single container, or a pack of future-like elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the completed task, or <code>std::nullopt</code> if there are no completed tasks (possible if current task was cancelled). </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d1c/wait__any_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../d2/d1c/wait__any_8hpp_source.html">wait_any.hpp</a>.</p>

</div>
</div>
<a id="gaaf870021139920ee54a13682178a0c0c" name="gaaf870021139920ee54a13682178a0c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf870021139920ee54a13682178a0c0c">&#9670;&#160;</a></span>WaitForSubscribableFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubscribableFuture &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void drivers::WaitForSubscribableFuture </td>
          <td>(</td>
          <td class="paramtype">SubscribableFuture &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>future</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits on the given future as described on <a class="el" href="../../df/db9/classdrivers_1_1SubscribableFutureWrapper.html" title="An adaptor for working with certain external futures.">drivers::SubscribableFutureWrapper</a>. </p>
<p>The result can be retrieved from the original future once ready.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../de/dae/classengine_1_1WaitInterruptedException.html">engine::WaitInterruptedException</a></td><td>on task cancellation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d01/subscribable__futures_8hpp_source.html#l00085">85</a> of file <a class="el" href="../../d8/d01/subscribable__futures_8hpp_source.html">subscribable_futures.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 21 2024 13:56:00 for userver by
    <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.10.0</li>
  </ul>
</div>
<script type="text/javascript" src="../../codeHighlight.js"></script>
<script type="text/javascript" src="../../telegramLanguage.js"></script>
<script type="text/javascript" src="../../styledBtn.js"></script>
<script type="text/javascript" src="../../search.js"></script>
<script type="text/javascript" src="../../header.js"></script>
<script type="text/javascript" src="../../searchHighlight.js"></script>
<script>
  const addLinks = () =>  {
      const links = document.createElement('div')
      links.id = 'links';
      links.innerHTML = `
          <a href="https://github.com/userver-framework/" id='github_header' rel="noopener" target="_blank" class="titlelink">
              <img src="../../github_logo.svg" alt="Github" class="gh-logo"/>
          </a>
          <a href="https://t.me/userver_en" rel="noopener" id='telegram_channel' target="_blank" class="titlelink generic_tg_link">
              <img src="../../telegram_logo.svg" alt="Telegram"/>
          </a>
      `
      document.getElementById('main-navbar').appendChild(links);
  }
  $(function() {
    $(document).ready(function() {
      setTimeout(() => {
      init_all_results_button();
      init_search_hotkey();
      init_header();
      addLinks();
      changeTelegramChannelLanguageForRussianSpeakingUser();
      document.getElementById("side-nav").style.display = "none";
      const isLanding = document.getElementById('landing_logo_id') !== null;
      if (isLanding) return;
      highlight_code();
      styleNavButtons();
    }, 0);
    });
  });
</script>
<script type="module" src="../../toc.js"></script>
</body>
</html>
